{"version":3,"file":"graphology.cjs.js","sources":["../src/utils.js","../src/errors.js","../src/data.js","../src/indices.js","../src/attributes/nodes.js","../src/attributes/edges.js","../src/iteration/edges.js","../src/iteration/neighbors.js","../src/iteration/adjacency.js","../src/serialization.js","../src/graph.js","../src/classes.js","../src/endpoint.cjs.js"],"sourcesContent":["/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a Graph implementation instance.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function'\n  );\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' && value !== null && value.constructor === Object\n  );\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.directedSelfLoops = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\nDirectedNodeData.prototype.upgradeToMixed = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\nUndirectedNodeData.prototype.upgradeToMixed = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n","/**\n * Graphology Indexes Functions\n * =============================\n *\n * Bunch of functions used to compute or clear indexes.\n */\n\n/**\n * Function updating the 'structure' index with the given edge's data.\n * Note that in the case of the multi graph, related edges are stored in a\n * set that is the same for A -> B & B <- A.\n *\n * @param {Graph}    graph      - Target Graph instance.\n * @param {EdgeData} edgeData   - Added edge's data.\n * @param {NodeData} sourceData - Source node's data.\n * @param {NodeData} targetData - Target node's data.\n */\nexport function updateStructureIndex(\n  graph,\n  undirected,\n  edgeData,\n  source,\n  target,\n  sourceData,\n  targetData\n) {\n  const multi = graph.multi;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (undirected) outKey = inKey = 'undirected';\n\n  let adj, container;\n\n  if (multi) {\n    // Handling source\n    adj = sourceData[outKey];\n    container = adj[target];\n\n    if (typeof container === 'undefined') {\n      container = new Set();\n      adj[target] = container;\n    }\n\n    container.add(edgeData);\n\n    // If selfLoop, we break here\n    if (source === target && undirected) return;\n\n    // Handling target (we won't add the edge because it was already taken\n    // care of with source above)\n    adj = targetData[inKey];\n    if (typeof adj[source] === 'undefined') adj[source] = container;\n  } else {\n    // Handling source\n    sourceData[outKey][target] = edgeData;\n\n    // If selfLoop, we break here\n    if (source === target && undirected) return;\n\n    // Handling target\n    targetData[inKey][source] = edgeData;\n  }\n}\n\n/**\n * Function clearing the 'structure' index data related to the given edge.\n *\n * @param {Graph}    graph    - Target Graph instance.\n * @param {EdgeData} edgeData - Dropped edge's data.\n */\nexport function clearEdgeFromStructureIndex(graph, undirected, edgeData) {\n  const multi = graph.multi;\n\n  const {source: sourceData, target: targetData} = edgeData;\n\n  const source = sourceData.key,\n    target = targetData.key;\n\n  // NOTE: since the edge set is the same for source & target, we can only\n  // affect source\n  const outKey = undirected ? 'undirected' : 'out',\n    sourceIndex = sourceData[outKey];\n\n  const inKey = undirected ? 'undirected' : 'in';\n\n  if (target in sourceIndex) {\n    if (multi) {\n      const set = sourceIndex[target];\n\n      if (set.size === 1) {\n        delete sourceIndex[target];\n        delete targetData[inKey][source];\n      } else {\n        set.delete(edgeData);\n      }\n    } else delete sourceIndex[target];\n  }\n\n  if (multi) return;\n\n  const targetIndex = targetData[inKey];\n\n  delete targetIndex[source];\n}\n\n/**\n * Function clearing the whole 'structure' index.\n *\n * @param {Graph} graph - Target Graph instance.\n */\nexport function clearStructureIndex(graph) {\n  const iterator = graph._nodes.values();\n\n  let step;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    step.value.clear();\n  }\n}\n\n/**\n * Function used to upgrade a simple `structure` index to a multi on.\n *\n * @param {Graph}  graph - Target Graph instance.\n */\nexport function upgradeStructureIndexToMulti(graph) {\n  graph._nodes.forEach((data, node) => {\n    // Directed\n    if (data.out) {\n      for (const neighbor in data.out) {\n        const edges = new Set();\n        edges.add(data.out[neighbor]);\n        data.out[neighbor] = edges;\n        graph._nodes.get(neighbor).in[node] = edges;\n      }\n    }\n\n    // Undirected\n    if (data.undirected) {\n      for (const neighbor in data.undirected) {\n        if (neighbor > node) continue;\n\n        const edges = new Set();\n        edges.add(data.undirected[neighbor]);\n        data.undirected[neighbor] = edges;\n        graph._nodes.get(neighbor).undirected[node] = edges;\n      }\n    }\n  });\n}\n","/**\n * Graphology Node Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject} from '../utils';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\nconst NODE = 0;\nconst SOURCE = 1;\nconst TARGET = 2;\nconst OPPOSITE = 3;\n\nfunction findRelevantNodeData(\n  graph,\n  method,\n  mode,\n  nodeOrEdge,\n  nameOrEdge,\n  add1,\n  add2\n) {\n  let nodeData, edgeData, arg1, arg2;\n\n  nodeOrEdge = '' + nodeOrEdge;\n\n  if (mode === NODE) {\n    nodeData = graph._nodes.get(nodeOrEdge);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" node in the graph.`\n      );\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  } else if (mode === OPPOSITE) {\n    nameOrEdge = '' + nameOrEdge;\n\n    edgeData = graph._edges.get(nameOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nameOrEdge}\" edge in the graph.`\n      );\n\n    const source = edgeData.source.key;\n    const target = edgeData.target.key;\n\n    if (nodeOrEdge === source) {\n      nodeData = edgeData.target;\n    } else if (nodeOrEdge === target) {\n      nodeData = edgeData.source;\n    } else {\n      throw new NotFoundGraphError(\n        `Graph.${method}: the \"${nodeOrEdge}\" node is not attached to the \"${nameOrEdge}\" edge (${source}, ${target}).`\n      );\n    }\n\n    arg1 = add1;\n    arg2 = add2;\n  } else {\n    edgeData = graph._edges.get(nodeOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" edge in the graph.`\n      );\n\n    if (mode === SOURCE) {\n      nodeData = edgeData.source;\n    } else {\n      nodeData = edgeData.target;\n    }\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  }\n\n  return [nodeData, arg1, arg2];\n}\n\nfunction attachNodeAttributeGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes[name];\n  };\n}\n\nfunction attachNodeAttributesGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {\n    const [data] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge\n    );\n\n    return data.attributes;\n  };\n}\n\nfunction attachNodeAttributeChecker(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\nfunction attachNodeAttributeSetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, value] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeRemover(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesReplacer(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesMerger(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst NODE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachNodeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachNodeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachNodeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachNodeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachNodeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachNodeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachNodeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachNodeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachNodeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachNodeAttributesMethods(Graph) {\n  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For nodes\n    attacher(Graph, name('Node'), NODE);\n\n    // For sources\n    attacher(Graph, name('Source'), SOURCE);\n\n    // For targets\n    attacher(Graph, name('Target'), TARGET);\n\n    // For opposites\n    attacher(Graph, name('Opposite'), OPPOSITE);\n  });\n}\n","/**\n * Graphology Edge Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject, getMatchingEdge} from '../utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from '../errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesMerger(Class, method, type) {\n  /**\n   * Merge the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesUpdater(Class, method, type) {\n  /**\n   * Update the attributes of the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + updater;\n\n      updater = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst EDGE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachEdgeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachEdgeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachEdgeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachEdgeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachEdgeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachEdgeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachEdgeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachEdgeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachEdgeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachEdgeAttributesMethods(Graph) {\n  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function collecting edges from the given object.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @return {array}         - The found edges.\n */\nfunction collectSimple(edges, object) {\n  for (const k in object) edges.push(object[k].key);\n}\n\nfunction collectMulti(edges, object) {\n  for (const k in object)\n    object[k].forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over edges from the given object using a callback.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n  }\n}\n\nfunction forEachMulti(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    object[k].forEach(edgeData =>\n      callback(\n        edgeData.key,\n        edgeData.attributes,\n        edgeData.source.key,\n        edgeData.target.key,\n        edgeData.source.attributes,\n        edgeData.target.attributes,\n        edgeData.undirected\n      )\n    );\n  }\n}\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction findSimple(object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction findMulti(object, callback, avoid) {\n  let iterator, step, edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    iterator = object[k].values();\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (shouldBreak) return edgeData.key;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object),\n    l = keys.length;\n\n  let inner = null,\n    i = 0;\n\n  return new Iterator(function next() {\n    let edgeData;\n\n    if (inner) {\n      const step = inner.next();\n\n      if (step.done) {\n        inner = null;\n        i++;\n        return next();\n      }\n\n      edgeData = step.value;\n    } else {\n      if (i >= l) return {done: true};\n\n      const k = keys[i];\n\n      if (k === avoid) {\n        i++;\n        return next();\n      }\n\n      edgeData = object[k];\n\n      if (edgeData instanceof Set) {\n        inner = edgeData.values();\n        return next();\n      }\n\n      i++;\n    }\n\n    return {\n      done: false,\n      value: {\n        edge: edgeData.key,\n        attributes: edgeData.attributes,\n        source: edgeData.source.key,\n        target: edgeData.target.key,\n        sourceAttributes: edgeData.source.attributes,\n        targetAttributes: edgeData.target.attributes,\n        undirected: edgeData.undirected\n      }\n    };\n  });\n}\n\n/**\n * Function collecting edges from the given object at given key.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @param  {mixed}  k      - Neighbor key.\n * @return {array}         - The found edges.\n */\nfunction collectForKeySimple(edges, object, k) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  edges.push(edgeData.key);\n}\n\nfunction collectForKeyMulti(edges, object, k) {\n  const edgesData = object[k];\n\n  if (!edgesData) return;\n\n  edgesData.forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  callback(\n    edgeData.key,\n    edgeData.attributes,\n    sourceData.key,\n    targetData.key,\n    sourceData.attributes,\n    targetData.attributes,\n    edgeData.undirected\n  );\n}\n\nfunction forEachForKeyMulti(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData) return;\n\n  edgesData.forEach(edgeData =>\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    )\n  );\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction findForKeySimple(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    )\n  )\n    return edgeData.key;\n}\n\nfunction findForKeyMulti(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData) return;\n\n  let shouldBreak = false;\n\n  const iterator = edgesData.values();\n  let step, edgeData;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    edgeData = step.value;\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  const v = object[k];\n\n  if (v instanceof Set) {\n    const iterator = v.values();\n\n    return new Iterator(function () {\n      const step = iterator.next();\n\n      if (step.done) return step;\n\n      const edgeData = step.value;\n\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    });\n  }\n\n  return Iterator.of([\n    v.key,\n    v.attributes,\n    v.source.key,\n    v.target.key,\n    v.source.attributes,\n    v.target.attributes\n  ]);\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    if (typeof Array.from === 'function')\n      return Array.from(graph._edges.keys());\n\n    return take(graph._edges.keys(), graph._edges.size);\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n  }\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction findEdge(graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return Iterator.empty();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    let step, data;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      step = iterator.next();\n\n      if (step.done) return step;\n\n      data = step.value;\n\n      if (shouldFilter && data.undirected !== mask) continue;\n\n      break;\n    }\n\n    const value = {\n      edge: data.key,\n      attributes: data.attributes,\n      source: data.source.key,\n      target: data.target.key,\n      sourceAttributes: data.source.attributes,\n      targetAttributes: data.target.attributes,\n      undirected: data.undirected\n    };\n\n    return {value, done: false};\n  });\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = [];\n\n  const fn = multi ? collectMulti : collectSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') fn(edges, nodeData.in);\n    if (direction !== 'in') fn(edges, nodeData.out);\n\n    // Handling self loop edge case\n    if (!direction && nodeData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(nodeData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    fn(edges, nodeData.undirected);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') fn(nodeData.in, callback);\n    if (direction !== 'in')\n      fn(nodeData.out, callback, !direction ? nodeData.key : null);\n  }\n\n  if (type !== 'directed') {\n    fn(nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction findEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? findMulti : findSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(nodeData.in, callback);\n\n      if (found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(nodeData.out, callback, !direction ? nodeData.key : null);\n\n      if (found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(nodeData.undirected, callback);\n\n    if (found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : null)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const fn = multi ? collectForKeyMulti : collectForKeySimple;\n\n  const edges = [];\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(edges, sourceData.in, target);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      fn(edges, sourceData.out, target);\n\n    // Handling self loop edge case\n    if (!direction && sourceData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(sourceData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(edges, sourceData.undirected, target);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over edges for the given path using a callback.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(sourceData.in, target, callback);\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n        fn(sourceData.out, target, callback);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(sourceData.undirected, target, callback);\n  }\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction findEdgeForPath(type, multi, direction, sourceData, target, callback) {\n  const fn = multi ? findForKeyMulti : findForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(sourceData.in, target, callback);\n\n      if (found) return found;\n    }\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in') {\n        found = fn(\n          sourceData.out,\n          target,\n          callback,\n          !direction ? sourceData.key : null\n        );\n\n        if (found) return found;\n      }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(sourceData.undirected, target, callback);\n\n      if (found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return findEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return findEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return findEdgeForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {NotFoundGraphError, InvalidArgumentsGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function merging neighbors into the given set iterating over the given object.\n *\n * @param {BasicSet} neighbors - Neighbors set.\n * @param {object}   object    - Target object.\n */\nfunction merge(neighbors, object) {\n  if (typeof object === 'undefined') return;\n\n  for (const neighbor in object) neighbors.add(neighbor);\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const neighbors = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      merge(neighbors, nodeData.in);\n    }\n    if (direction !== 'in') {\n      merge(neighbors, nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    merge(neighbors, nodeData.undirected);\n  }\n\n  return take(neighbors.values(), neighbors.size);\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    callback(neighborData.key, neighborData.attributes);\n  }\n}\n\nfunction forEachInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key)) continue;\n\n    visited.add(neighborData.key);\n\n    callback(neighborData.key, neighborData.attributes);\n  }\n}\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction findInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction findInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key)) continue;\n\n    visited.add(neighborData.key);\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighborForNode(type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      forEachInObjectOnce(visited, nodeData, nodeData.in, callback);\n    }\n    if (direction !== 'in') {\n      forEachInObjectOnce(visited, nodeData, nodeData.out, callback);\n    }\n  }\n\n  if (type !== 'directed') {\n    forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n  }\n}\n\nfunction findNeighbor(type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return findInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return findInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = findInObjectOnce(visited, nodeData, nodeData.in, callback);\n\n      if (found) return found;\n    }\n    if (direction !== 'in') {\n      found = findInObjectOnce(visited, nodeData, nodeData.out, callback);\n\n      if (found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = findInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n\n    if (found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createObjectIterator(nodeData, object) {\n  const keys = Object.keys(object),\n    l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    return {\n      done: false,\n      value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n    };\n  });\n}\n\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object),\n    l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    if (i >= l) return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key)) return next();\n\n    visited.add(neighborData.key);\n\n    return {\n      done: false,\n      value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createObjectIterator(nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createObjectIterator(nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighborForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return findNeighbor(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Adjacency Iteration\n * ================================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nexport function forEachAdjacencySimple(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        hasEdges = true;\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected\n        );\n\n        if (breakable && shouldBreak) return edgeData;\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        if (targetData.key !== neighbor) targetData = edgeData.source;\n\n        hasEdges = true;\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected\n        );\n\n        if (breakable && shouldBreak) return edgeData;\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function iterating over a multi graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nexport function forEachAdjacencyMulti(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step;\n  let sourceData;\n  let neighbor;\n  let container;\n  let containerStep;\n  let adj;\n  let edgeData;\n  let targetData;\n  let shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        container = adj[neighbor].values();\n\n        while (\n          ((containerStep = container.next()), containerStep.done !== true)\n        ) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n        }\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        container = adj[neighbor].values();\n\n        while (\n          ((containerStep = container.next()), containerStep.done !== true)\n        ) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n        }\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n\n// export function createAdjacencyIteratorSimple(graph) {\n//   const iterator = graph._nodes.values();\n\n//   const type = graph.type;\n\n//   let state = 'outer',\n//     sourceData,\n//     neighbors,\n//     adj,\n//     offset;\n\n//   return new Iterator(function next() {\n//     let step;\n\n//     if (state === 'outer') {\n//       step = iterator.next();\n\n//       if (step.done === true) return step;\n\n//       sourceData = step.value;\n\n//       state = 'directed';\n//       return next();\n//     }\n\n//     if (state === 'directed') {\n//       if (type === 'undirected') {\n//         state = 'undirected';\n//         return next();\n//       }\n\n//       adj = sourceData.out;\n//       neighbors = Object.keys(sourceData.out);\n//       offset = 0;\n//       state = 'inner-directed';\n\n//       return next();\n//     }\n\n//     if (state === 'undirected') {\n//       if (type === 'directed') {\n//         state = 'outer';\n//         return next();\n//       }\n\n//       adj = sourceData.undirected;\n//       neighbors = Object.keys(sourceData.undirected);\n//       offset = 0;\n//       state = 'inner-undirected';\n//     }\n\n//     // Inner\n//     if (offset >= neighbors.length) {\n//       if (state === 'inner-undirected') state = 'outer';\n//       else state = 'undirected';\n\n//       return next();\n//     }\n\n//     const neighbor = neighbors[offset++];\n//     const edgeData = adj[neighbor];\n//     let targetData = edgeData.target;\n\n//     if (state === 'inner-undirected' && targetData.key === sourceData.key)\n//       targetData = edgeData.source;\n\n//     return {\n//       done: false,\n//       value: {\n//         source: sourceData.key,\n//         target: targetData.key,\n//         sourceAttributes: sourceData.attributes,\n//         targetAttributes: targetData.attributes,\n//         edgeKey: edgeData.key,\n//         edgeAttributes: edgeData.attributes,\n//         undirected: edgeData.undirected\n//       }\n//     };\n//   });\n// }\n\n// export function createAdjacencyIteratorMulti(graph) {\n//   const iterator = graph._nodes.values();\n\n//   const type = graph.type;\n\n//   let state = 'outer',\n//     sourceData,\n//     neighbors,\n//     container = null,\n//     adj,\n//     offset;\n\n//   return new Iterator(function next() {\n//     let step;\n\n//     if (state === 'outer') {\n//       step = iterator.next();\n\n//       if (step.done === true) return step;\n\n//       sourceData = step.value;\n\n//       state = 'directed';\n//       return next();\n//     }\n\n//     if (state === 'directed') {\n//       if (type === 'undirected') {\n//         state = 'undirected';\n//         return next();\n//       }\n\n//       adj = sourceData.out;\n//       neighbors = Object.keys(sourceData.out);\n//       offset = 0;\n//       state = 'inner-directed';\n\n//       return next();\n//     }\n\n//     if (state === 'undirected') {\n//       if (type === 'directed') {\n//         state = 'outer';\n//         return next();\n//       }\n\n//       adj = sourceData.undirected;\n//       neighbors = Object.keys(sourceData.undirected);\n//       offset = 0;\n//       state = 'inner-undirected';\n//     }\n\n//     // Inner\n//     if (!container && offset >= neighbors.length) {\n//       if (state === 'inner-undirected') state = 'outer';\n//       else state = 'undirected';\n\n//       return next();\n//     }\n\n//     if (!container) {\n//       const neighbor = neighbors[offset++];\n//       container = adj[neighbor].values();\n//       return next();\n//     }\n\n//     step = container.next();\n\n//     if (step.done) {\n//       container = null;\n//       return next();\n//     }\n\n//     const edgeData = step.value;\n//     let targetData = edgeData.target;\n\n//     if (state === 'inner-undirected' && targetData.key === sourceData.key)\n//       targetData = edgeData.source;\n\n//     return {\n//       done: false,\n//       value: {\n//         source: sourceData.key,\n//         target: targetData.key,\n//         sourceAttributes: sourceData.attributes,\n//         targetAttributes: targetData.attributes,\n//         edge: edgeData.key,\n//         edgeAttributes: edgeData.attributes,\n//         undirected: edgeData.undirected\n//       }\n//     };\n//   });\n// }\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used to validate import-export formats & to ouput\n * them from internal graph data.\n *\n * Serialized Node:\n * {key, ?attributes}\n *\n * Serialized Edge:\n * {key?, source, target, attributes?, undirected?}\n *\n * Serialized Graph:\n * {nodes[], edges?[]}\n */\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value)) return 'not-object';\n\n  if (!('key' in value)) return 'no-key';\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    return 'invalid-attributes';\n\n  return null;\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value)) return 'not-object';\n\n  if (!('source' in value)) return 'no-source';\n\n  if (!('target' in value)) return 'no-target';\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    return 'invalid-attributes';\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    return 'invalid-undirected';\n\n  return null;\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport {\n  updateStructureIndex,\n  clearEdgeFromStructureIndex,\n  clearStructureIndex,\n  upgradeStructureIndexToMulti\n} from './indices';\n\nimport attachNodeAttributesMethods from './attributes/nodes';\nimport attachEdgeAttributesMethods from './attributes/edges';\nimport attachEdgeIterationMethods from './iteration/edges';\nimport attachNeighborIterationMethods from './iteration/neighbors';\nimport {\n  forEachAdjacencySimple,\n  forEachAdjacencyMulti\n} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isGraph,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalIdStartingFromRandomByte,\n  validateHints\n} from './utils';\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    } else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  } else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    } else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source);\n  let targetData = graph._nodes.get(target);\n  let edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are coherent\n      if (\n        edgeData.source.key !== source ||\n        edgeData.target.key !== target ||\n        (undirected &&\n          (edgeData.source.key !== target || edgeData.target.key !== source))\n      ) {\n        throw new UsageGraphError(\n          `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n        );\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    const info = [alreadyExistingEdgeData.key, false, false, false];\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return info;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return info;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  let sourceWasAdded = false;\n  let targetWasAdded = false;\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n    sourceWasAdded = true;\n\n    if (source === target) {\n      targetData = sourceData;\n      targetWasAdded = true;\n    }\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n    targetWasAdded = true;\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    } else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  } else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    } else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return [edge, true, sourceWasAdded, targetWasAdded];\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instanceId = INSTANCE_ID();\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = 'geid_' + instanceId + '_' + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.out[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.undirected[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n\n      if (!edges)\n        edges =\n          typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.directedSelfLoops;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree + nodeData.directedSelfLoops;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    const loops = nodeData.directedSelfLoops;\n\n    const inDegree = nodeData.inDegree + loops;\n    const outDegree = nodeData.outDegree + loops;\n\n    return inDegree + outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    const loops = nodeData.undirectedSelfLoops;\n\n    return nodeData.undirectedDegree + loops * 2;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree + nodeData.undirectedSelfLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree +=\n        nodeData.inDegree + nodeData.outDegree + nodeData.directedSelfLoops * 2;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key;\n    const target = data.target.key;\n\n    if (node === source) return target;\n    if (node === target) return source;\n\n    throw new NotFoundGraphError(\n      `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n    );\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return [node, false];\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return [node, false];\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Removing attached edges\n    // TODO: we could do faster\n    this.forEachEdge(node, edge => {\n      this.dropEdge(edge);\n    });\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0],\n        target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    // Dropping the edge from the register\n    this._edges.delete(edgeData.key);\n\n    // Updating related degrees\n    const {source: sourceData, target: targetData, attributes} = edgeData;\n\n    const undirected = edgeData.undirected;\n\n    if (sourceData === targetData) {\n      if (undirected) {\n        sourceData.undirectedSelfLoops--;\n        this._undirectedSelfLoopCount--;\n      } else {\n        sourceData.directedSelfLoops--;\n        this._directedSelfLoopCount--;\n      }\n    } else {\n      if (undirected) {\n        sourceData.undirectedDegree--;\n        targetData.undirectedDegree--;\n      } else {\n        sourceData.outDegree--;\n        targetData.inDegree--;\n      }\n    }\n\n    // Clearing index\n    clearEdgeFromStructureIndex(this, undirected, edgeData);\n\n    if (undirected) this._undirectedSize--;\n    else this._directedSize--;\n\n    // Emitting\n    this.emit('edgeDropped', {\n      key: edge,\n      attributes,\n      source: sourceData.key,\n      target: targetData.key,\n      undirected\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    clearStructureIndex(this);\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method updating the graph's attributes.\n   *\n   * @param  {function} updater - Function used to update the attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given updater is not a function.\n   */\n  updateAttributes(updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttributes: provided updater is not a function.'\n      );\n\n    this._attributes = updater(this._attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'update',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData, sourceData, targetData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      sourceData = edgeData.source;\n      targetData = edgeData.target;\n\n      edgeData.attributes = updater(\n        edgeData.key,\n        edgeData.attributes,\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.undirected\n      );\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntry: expecting a callback.'\n      );\n\n    if (this.multi) forEachAdjacencyMulti(false, false, false, this, callback);\n    else forEachAdjacencySimple(false, false, false, this, callback);\n  }\n  forEachAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    if (this.multi) forEachAdjacencyMulti(false, false, true, this, callback);\n    else forEachAdjacencySimple(false, false, true, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's assymetric adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAssymetricAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'\n      );\n\n    if (this.multi) forEachAdjacencyMulti(false, true, false, this, callback);\n    else forEachAdjacencySimple(false, true, false, this, callback);\n  }\n  forEachAssymetricAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    if (this.multi) forEachAdjacencyMulti(false, true, true, this, callback);\n    else forEachAdjacencySimple(false, true, true, this, callback);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    if (typeof Array.from === 'function') return Array.from(this._nodes.keys());\n\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done) return step;\n\n      const data = step.value;\n\n      return {\n        value: {node: data.key, attributes: data.attributes},\n        done: false\n      };\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method exporting the target node.\n   *\n   * @param  {any}   node - Target node.\n   * @return {array}      - The serialized node.\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  exportNode(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.exportNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    return serializeNode(node, data);\n  }\n\n  /**\n   * Method exporting the target edge.\n   *\n   * @param  {any}   edge - Target edge.\n   * @return {array}      - The serialized edge.\n   *\n   * @throws {Error} - Will throw if the edge is not found.\n   */\n  exportEdge(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.exportEdge: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return serializeEdge(edge, data);\n  }\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(key, data);\n    });\n\n    return {\n      attributes: this.getAttributes(),\n      nodes,\n      edges,\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      }\n    };\n  }\n\n  /**\n   * Method used to import a serialized node.\n   *\n   * @param  {object} data   - The serialized node.\n   * @param  {boolean} merge - Whether to merge the given node.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importNode(data, merge = false) {\n    // Validating\n    const error = validateSerializedNode(data);\n\n    if (error) {\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n        );\n      if (error === 'no-key')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importNode: no key provided.'\n        );\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.'\n        );\n    }\n\n    // Adding the node\n    const {key, attributes = {}} = data;\n\n    if (merge) this.mergeNode(key, attributes);\n    else this.addNode(key, attributes);\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized edge.\n   *\n   * @param  {object}  data  - The serialized edge.\n   * @param  {boolean} merge - Whether to merge the given edge.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importEdge(data, merge = false) {\n    // Validating\n    const error = validateSerializedEdge(data);\n\n    if (error) {\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n        );\n      if (error === 'no-source')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: missing souce.'\n        );\n      if (error === 'no-target')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: missing target.'\n        );\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.'\n        );\n      if (error === 'invalid-undirected')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.'\n        );\n    }\n\n    // Adding the edge\n    const {source, target, attributes = {}, undirected = false} = data;\n\n    let method;\n\n    if ('key' in data) {\n      method = merge\n        ? undirected\n          ? this.mergeUndirectedEdgeWithKey\n          : this.mergeDirectedEdgeWithKey\n        : undirected\n        ? this.addUndirectedEdgeWithKey\n        : this.addDirectedEdgeWithKey;\n\n      method.call(this, data.key, source, target, attributes);\n    } else {\n      method = merge\n        ? undirected\n          ? this.mergeUndirectedEdge\n          : this.mergeDirectedEdge\n        : undirected\n        ? this.addUndirectedEdge\n        : this.addDirectedEdge;\n\n      method.call(this, source, target, attributes);\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance\n    if (isGraph(data)) {\n      this.import(data.export(), merge);\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) this.importNode(list[i], merge);\n    }\n\n    if (data.edges) {\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) this.importEdge(list[i], merge);\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n    graph.replaceAttributes(assign({}, this.getAttributes()));\n    return graph;\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @return {Graph} - The copy.\n   */\n  copy() {\n    const graph = this.emptyCopy();\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      addEdge(\n        graph,\n        'copy',\n        false,\n        edgeData.undirected,\n        edgeData.key,\n        edgeData.source.key,\n        edgeData.target.key,\n        assign({}, edgeData.attributes)\n      );\n    }\n\n    return graph;\n  }\n\n  /**\n   * Method upgrading the graph to a mixed one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMixed() {\n    if (this.type === 'mixed') return this;\n\n    // Upgrading node data:\n    // NOTE: maybe this could lead to some de-optimization by usual\n    // JavaScript engines but I cannot be sure of it. Another solution\n    // would be to reinstantiate the classes but this surely has a performance\n    // and memory impact.\n    this._nodes.forEach(data => data.upgradeToMixed());\n\n    // Mutating the options & the instance\n    this._options.type = 'mixed';\n    readOnlyProperty(this, 'type', this._options.type);\n    privateProperty(this, 'NodeDataClass', MixedNodeData);\n\n    return this;\n  }\n\n  /**\n   * Method upgrading the graph to a multi one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMulti() {\n    if (this.multi) return this;\n\n    // Mutating the options & the instance\n    this._options.multi = true;\n    readOnlyProperty(this, 'multi', true);\n\n    // Upgrading indices\n    upgradeStructureIndexToMulti(this);\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function' &&\n        typeof k !== 'symbol'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Attributes-related.\n */\nattachNodeAttributesMethods(Graph);\nattachEdgeAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n","/**\n * Graphology CommonJS Endoint\n * ============================\n *\n * Endpoint for CommonJS modules consumers.\n */\nimport {Graph} from './classes';\n\nexport default Graph;\n"],"names":["assignPolyfill","target","arguments","i","l","length","k","assign","Object","getMatchingEdge","graph","source","type","sourceData","_nodes","get","edge","out","undirected","isGraph","value","addUndirectedEdgeWithKey","dropNode","isPlainObject","constructor","isEmpty","o","privateProperty","name","defineProperty","enumerable","configurable","writable","readOnlyProperty","descriptor","validateHints","hints","attributes","Array","isArray","incrementalIdStartingFromRandomByte","Math","floor","random","GraphError","message","Error","InvalidArgumentsGraphError","captureStackTrace","prototype","NotFoundGraphError","UsageGraphError","MixedNodeData","key","clear","inDegree","outDegree","undirectedDegree","directedSelfLoops","undirectedSelfLoops","DirectedNodeData","upgradeToMixed","UndirectedNodeData","EdgeData","updateStructureIndex","edgeData","targetData","multi","outKey","inKey","adj","container","Set","add","clearEdgeFromStructureIndex","sourceIndex","set","size","targetIndex","clearStructureIndex","iterator","values","step","next","done","upgradeStructureIndexToMulti","forEach","data","node","neighbor","edges","NODE","SOURCE","TARGET","OPPOSITE","findRelevantNodeData","method","mode","nodeOrEdge","nameOrEdge","add1","add2","nodeData","arg1","arg2","_edges","attachNodeAttributeGetter","Class","attachNodeAttributesGetter","attachNodeAttributeChecker","hasOwnProperty","attachNodeAttributeSetter","emit","attachNodeAttributeUpdater","updater","attachNodeAttributeRemover","attachNodeAttributesReplacer","attachNodeAttributesMerger","attachNodeAttributesUpdater","NODE_ATTRIBUTES_METHODS","element","attacher","attachNodeAttributesMethods","Graph","attachEdgeAttributeGetter","attachEdgeAttributesGetter","attachEdgeAttributeChecker","attachEdgeAttributeSetter","attachEdgeAttributeUpdater","attachEdgeAttributeRemover","attachEdgeAttributesReplacer","attachEdgeAttributesMerger","attachEdgeAttributesUpdater","EDGE_ATTRIBUTES_METHODS","attachEdgeAttributesMethods","EDGES_ITERATION","direction","collectSimple","object","push","collectMulti","forEachSimple","callback","avoid","forEachMulti","findSimple","shouldBreak","findMulti","createIterator","keys","inner","Iterator","sourceAttributes","targetAttributes","collectForKeySimple","collectForKeyMulti","edgesData","forEachForKeySimple","forEachForKeyMulti","findForKeySimple","findForKeyMulti","createIteratorForKey","v","of","createEdgeArray","from","take","undirectedSize","directedSize","list","mask","forEachEdge","shouldFilter","findEdge","createEdgeIterator","empty","createEdgeArrayForNode","fn","splice","lastIndexOf","forEachEdgeForNode","findEdgeForNode","found","createEdgeIteratorForNode","chain","createEdgeArrayForPath","forEachEdgeForPath","findEdgeForPath","createEdgeIteratorForPath","attachEdgeArrayCreator","description","has","attachForEachEdge","forEachName","toUpperCase","slice","mapName","args","call","pop","result","e","ea","s","t","sa","ta","u","apply","filterName","reduceName","initialValue","accumulator","attachFindEdge","findEdgeName","someName","everyName","attachEdgeIteratorCreator","originalName","attachEdgeIterationMethods","NEIGHBORS_ITERATION","merge","neighbors","createNeighborArrayForNode","forEachInObject","neighborData","forEachInObjectOnce","visited","findInObject","findInObjectOnce","forEachNeighborForNode","findNeighbor","createObjectIterator","createDedupedObjectIterator","createNeighborIterator","attachNeighborArrayCreator","attachForEachNeighbor","n","a","attachFindNeighbor","capitalizedSingular","findName","attachNeighborIteratorCreator","iteratorName","attachNeighborIterationMethods","forEachAdjacencySimple","breakable","assymetric","disconnectedNodes","hasEdges","forEachAdjacencyMulti","containerStep","serializeNode","serialized","serializeEdge","validateSerializedNode","validateSerializedEdge","INSTANCE_ID","TYPES","EMITTER_PROPS","EDGE_ADD_METHODS","verb","generateKey","DEFAULTS","allowSelfLoops","addNode","NodeDataClass","unsafeAddNode","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","_undirectedSelfLoopCount","_directedSelfLoopCount","_undirectedSize","_directedSize","mergeEdge","asUpdater","undefined","alreadyExistingEdgeData","info","oldAttributes","sourceWasAdded","targetWasAdded","options","instanceId","edgeId","edgeKeyGenerator","availableEdgeKey","Map","prop","_options","_resetInstanceCounters","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undirectedEdge","areDirectedNeighbors","areOutNeighbors","areInNeighbors","areUndirectedNeighbors","areNeighbors","areInboundNeighbors","areOutboundNeighbors","directedDegree","loops","degree","inDegreeWithoutSelfLoops","outDegreeWithoutSelfLoops","directedDegreeWithoutSelfLoops","undirectedDegreeWithoutSelfLoops","degreeWithoutSelfLoops","extremities","opposite","hasExtremity","isUndirected","isDirected","isSelfLoop","mergeNode","updateNode","dropEdge","clearEdges","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","updateAttributes","updateEachNodeAttributes","updateEachEdgeAttributes","forEachAdjacencyEntry","forEachAdjacencyEntryWithOrphans","forEachAssymetricAdjacencyEntry","forEachAssymetricAdjacencyEntryWithOrphans","nodes","forEachNode","findNode","mapNodes","order","someNode","everyNode","filterNodes","reduceNodes","nodeEntries","exportNode","exportEdge","importNode","error","importEdge","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addDirectedEdgeWithKey","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","copy","upgradeToMulti","toJSON","toString","inspect","multiIndex","label","tmp","desc","startsWith","dummy","EventEmitter","Symbol","DirectedGraph","finalOptions","UndirectedGraph","MultiGraph","MultiDirectedGraph","MultiUndirectedGraph","attachStaticFromMethod","instance"],"mappings":"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AACb,GAFS,EAGpBxC,UAAU,CAACwB,UAHS,EAIpB6B,UAAU,CAAC7B,UAJS,EAKpB4B,QAAQ,CAACZ,GALW,EAMpBY,QAAQ,CAAC5B,UANW,EAOpB4B,QAAQ,CAAC/C,UAPW,CAAtB;AAUA,cAAIoO,SAAS,IAAIpG,WAAjB,EAA8B,OAAOjF,QAAP;AAC/B;AACF;AACF;;AAED,QAAIuL,iBAAiB,IAAI,CAACC,QAA1B,EAAoC;AAClCvG,MAAAA,WAAW,GAAGJ,QAAQ,CACpBjI,UAAU,CAACwC,GADS,EAEpB,IAFoB,EAGpBxC,UAAU,CAACwB,UAHS,EAIpB,IAJoB,EAKpB,IALoB,EAMpB,IANoB,EAOpB,IAPoB,CAAtB;AAUA,UAAIiN,SAAS,IAAIpG,WAAjB,EAA8B,OAAO,IAAP;AAC/B;AACF;;AAED;AACD;AAGD;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACO,SAAS0G,aAAT,CAAuBvM,GAAvB,EAA4BkC,IAA5B,EAAkC;AACvC,MAAMsK,UAAU,GAAG;AAACxM,IAAAA,GAAG,EAAHA;AAAD,GAAnB;AAEA,MAAI,CAAC5B,OAAO,CAAC8D,IAAI,CAAClD,UAAN,CAAZ,EACEwN,UAAU,CAACxN,UAAX,GAAwB9B,MAAM,CAAC,EAAD,EAAKgF,IAAI,CAAClD,UAAV,CAA9B;AAEF,SAAOwN,UAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACO,SAASC,aAAT,CAAuBzM,GAAvB,EAA4BkC,IAA5B,EAAkC;AACvC,MAAMsK,UAAU,GAAG;AACjBxM,IAAAA,GAAG,EAAHA,GADiB;AAEjB1C,IAAAA,MAAM,EAAE4E,IAAI,CAAC5E,MAAL,CAAY0C,GAFH;AAGjBpD,IAAAA,MAAM,EAAEsF,IAAI,CAACtF,MAAL,CAAYoD;AAHH,GAAnB;AAMA,MAAI,CAAC5B,OAAO,CAAC8D,IAAI,CAAClD,UAAN,CAAZ,EACEwN,UAAU,CAACxN,UAAX,GAAwB9B,MAAM,CAAC,EAAD,EAAKgF,IAAI,CAAClD,UAAV,CAA9B;AAEF,MAAIkD,IAAI,CAACrE,UAAT,EAAqB2O,UAAU,CAAC3O,UAAX,GAAwB,IAAxB;AAErB,SAAO2O,UAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACO,SAASE,sBAAT,CAAgC3O,KAAhC,EAAuC;AAC5C,MAAI,CAACG,aAAa,CAACH,KAAD,CAAlB,EAA2B,OAAO,YAAP;AAE3B,MAAI,EAAE,SAASA,KAAX,CAAJ,EAAuB,OAAO,QAAP;AAEvB,MACE,gBAAgBA,KAAhB,KACC,CAACG,aAAa,CAACH,KAAK,CAACiB,UAAP,CAAd,IAAoCjB,KAAK,CAACiB,UAAN,KAAqB,IAD1D,CADF,EAIE,OAAO,oBAAP;AAEF,SAAO,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACO,SAAS2N,sBAAT,CAAgC5O,KAAhC,EAAuC;AAC5C,MAAI,CAACG,aAAa,CAACH,KAAD,CAAlB,EAA2B,OAAO,YAAP;AAE3B,MAAI,EAAE,YAAYA,KAAd,CAAJ,EAA0B,OAAO,WAAP;AAE1B,MAAI,EAAE,YAAYA,KAAd,CAAJ,EAA0B,OAAO,WAAP;AAE1B,MACE,gBAAgBA,KAAhB,KACC,CAACG,aAAa,CAACH,KAAK,CAACiB,UAAP,CAAd,IAAoCjB,KAAK,CAACiB,UAAN,KAAqB,IAD1D,CADF,EAIE,OAAO,oBAAP;AAEF,MAAI,gBAAgBjB,KAAhB,IAAyB,OAAOA,KAAK,CAACF,UAAb,KAA4B,SAAzD,EACE,OAAO,oBAAP;AAEF,SAAO,IAAP;AACD;;ACzCD;AACA;AACA;;AACA,IAAM+O,WAAW,GAAGzN,mCAAmC,EAAvD;AAEA;AACA;AACA;;AACA,IAAM0N,KAAK,GAAG,IAAI1L,GAAJ,CAAQ,CAAC,UAAD,EAAa,YAAb,EAA2B,OAA3B,CAAR,CAAd;AAEA,IAAM2L,aAAa,GAAG,IAAI3L,GAAJ,CAAQ,CAC5B,QAD4B,EAE5B,SAF4B,EAG5B,cAH4B,EAI5B,eAJ4B,CAAR,CAAtB;AAOA,IAAM4L,gBAAgB,GAAG,CACvB;AACExO,EAAAA,IAAI,EAAE,cAAAyO,IAAI;AAAA,qBAAOA,IAAP;AAAA,GADZ;AAEEC,EAAAA,WAAW,EAAE;AAFf,CADuB,EAKvB;AACE1O,EAAAA,IAAI,EAAE,cAAAyO,IAAI;AAAA,qBAAOA,IAAP;AAAA,GADZ;AAEEC,EAAAA,WAAW,EAAE,IAFf;AAGE1P,EAAAA,IAAI,EAAE;AAHR,CALuB,EAUvB;AACEgB,EAAAA,IAAI,EAAE,cAAAyO,IAAI;AAAA,qBAAOA,IAAP;AAAA,GADZ;AAEEC,EAAAA,WAAW,EAAE,IAFf;AAGE1P,EAAAA,IAAI,EAAE;AAHR,CAVuB,EAevB;AACEgB,EAAAA,IAAI,EAAE,cAAAyO,IAAI;AAAA,qBAAOA,IAAP;AAAA;AADZ,CAfuB,EAkBvB;AACEzO,EAAAA,IAAI,EAAE,cAAAyO,IAAI;AAAA,qBAAOA,IAAP;AAAA,GADZ;AAEEzP,EAAAA,IAAI,EAAE;AAFR,CAlBuB,EAsBvB;AACEgB,EAAAA,IAAI,EAAE,cAAAyO,IAAI;AAAA,qBAAOA,IAAP;AAAA,GADZ;AAEEzP,EAAAA,IAAI,EAAE;AAFR,CAtBuB,CAAzB;AA4BA;AACA;AACA;;AACA,IAAM2P,QAAQ,GAAG;AACfC,EAAAA,cAAc,EAAE,IADD;AAEfrM,EAAAA,KAAK,EAAE,KAFQ;AAGfvD,EAAAA,IAAI,EAAE;AAHS,CAAjB;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAS6P,QAAT,CAAiB/P,KAAjB,EAAwB8E,IAAxB,EAA8BnD,UAA9B,EAA0C;AACxC,MAAIA,UAAU,IAAI,CAACd,aAAa,CAACc,UAAD,CAAhC,EACE,MAAM,IAAIU,0BAAJ,4EAC+DV,UAD/D,QAAN,CAFsC;;AAOxCmD,EAAAA,IAAI,GAAG,KAAKA,IAAZ;AACAnD,EAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B;AAEA,MAAI3B,KAAK,CAACI,MAAN,CAAaiL,GAAb,CAAiBvG,IAAjB,CAAJ,EACE,MAAM,IAAIrC,eAAJ,gCACmBqC,IADnB,yCAAN;AAIF,MAAMD,IAAI,GAAG,IAAI7E,KAAK,CAACgQ,aAAV,CAAwBlL,IAAxB,EAA8BnD,UAA9B,CAAb,CAfwC;;AAkBxC3B,EAAAA,KAAK,CAACI,MAAN,CAAa8D,GAAb,CAAiBY,IAAjB,EAAuBD,IAAvB,EAlBwC;;;AAqBxC7E,EAAAA,KAAK,CAACsG,IAAN,CAAW,WAAX,EAAwB;AACtB3D,IAAAA,GAAG,EAAEmC,IADiB;AAEtBnD,IAAAA,UAAU,EAAVA;AAFsB,GAAxB;AAKA,SAAOkD,IAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASoL,aAAT,CAAuBjQ,KAAvB,EAA8B8E,IAA9B,EAAoCnD,UAApC,EAAgD;AAC9C,MAAMkD,IAAI,GAAG,IAAI7E,KAAK,CAACgQ,aAAV,CAAwBlL,IAAxB,EAA8BnD,UAA9B,CAAb;;AAEA3B,EAAAA,KAAK,CAACI,MAAN,CAAa8D,GAAb,CAAiBY,IAAjB,EAAuBD,IAAvB;;AAEA7E,EAAAA,KAAK,CAACsG,IAAN,CAAW,WAAX,EAAwB;AACtB3D,IAAAA,GAAG,EAAEmC,IADiB;AAEtBnD,IAAAA,UAAU,EAAVA;AAFsB,GAAxB;AAKA,SAAOkD,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqL,OAAT,CACElQ,KADF,EAEEkB,IAFF,EAGEiP,eAHF,EAIE3P,UAJF,EAKEF,IALF,EAMEL,MANF,EAOEV,MAPF,EAQEoC,UARF,EASE;AACA;AACA,MAAI,CAACnB,UAAD,IAAeR,KAAK,CAACE,IAAN,KAAe,YAAlC,EACE,MAAM,IAAIuC,eAAJ,iBACKvB,IADL,gHAAN;AAIF,MAAIV,UAAU,IAAIR,KAAK,CAACE,IAAN,KAAe,UAAjC,EACE,MAAM,IAAIuC,eAAJ,iBACKvB,IADL,8GAAN;AAIF,MAAIS,UAAU,IAAI,CAACd,aAAa,CAACc,UAAD,CAAhC,EACE,MAAM,IAAIU,0BAAJ,iBACKnB,IADL,iEAC+DS,UAD/D,QAAN,CAbF;;AAkBA1B,EAAAA,MAAM,GAAG,KAAKA,MAAd;AACAV,EAAAA,MAAM,GAAG,KAAKA,MAAd;AACAoC,EAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B;AAEA,MAAI,CAAC3B,KAAK,CAAC8P,cAAP,IAAyB7P,MAAM,KAAKV,MAAxC,EACE,MAAM,IAAIkD,eAAJ,iBACKvB,IADL,+CAC6CjB,MAD7C,wGAAN;;AAIF,MAAME,UAAU,GAAGH,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBJ,MAAjB,CAAnB;AAAA,MACEuD,UAAU,GAAGxD,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBd,MAAjB,CADf;;AAGA,MAAI,CAACY,UAAL,EACE,MAAM,IAAIqC,kBAAJ,iBACKtB,IADL,6BAC2BjB,MAD3B,mBAAN;AAIF,MAAI,CAACuD,UAAL,EACE,MAAM,IAAIhB,kBAAJ,iBACKtB,IADL,6BAC2B3B,MAD3B,mBAAN,CApCF;;AAyCA,MAAM6Q,SAAS,GAAG;AAChBzN,IAAAA,GAAG,EAAE,IADW;AAEhBnC,IAAAA,UAAU,EAAVA,UAFgB;AAGhBP,IAAAA,MAAM,EAANA,MAHgB;AAIhBV,IAAAA,MAAM,EAANA,MAJgB;AAKhBoC,IAAAA,UAAU,EAAVA;AALgB,GAAlB;;AAQA,MAAIwO,eAAJ,EAAqB;AACnB;AACA;AACA7P,IAAAA,IAAI,GAAGN,KAAK,CAACqQ,iBAAN,EAAP;AACD,GAJD,MAIO;AACL;AACA/P,IAAAA,IAAI,GAAG,KAAKA,IAAZ,CAFK;;AAKL,QAAIN,KAAK,CAAC+F,MAAN,CAAasF,GAAb,CAAiB/K,IAAjB,CAAJ,EACE,MAAM,IAAImC,eAAJ,iBACKvB,IADL,qBACmBZ,IADnB,0CAAN;AAGH,GA9DD;;;AAiEA,MACE,CAACN,KAAK,CAACyD,KAAP,KACCjD,UAAU,GACP,OAAOL,UAAU,CAACK,UAAX,CAAsBjB,MAAtB,CAAP,KAAyC,WADlC,GAEP,OAAOY,UAAU,CAACI,GAAX,CAAehB,MAAf,CAAP,KAAkC,WAHtC,CADF,EAKE;AACA,UAAM,IAAIkD,eAAJ,iBACKvB,IADL,iCAC+BjB,MAD/B,qBAC8CV,MAD9C,mJAAN;AAGD,GA1ED;;;AA6EA,MAAMgE,QAAQ,GAAG,IAAIF,QAAJ,CACf7C,UADe,EAEfF,IAFe,EAGfH,UAHe,EAIfqD,UAJe,EAKf7B,UALe,CAAjB,CA7EA;;AAsFA3B,EAAAA,KAAK,CAAC+F,MAAN,CAAa7B,GAAb,CAAiB5D,IAAjB,EAAuBiD,QAAvB,EAtFA;;;AAyFA,MAAItD,MAAM,KAAKV,MAAf,EAAuB;AACrB,QAAIiB,UAAJ,EAAgB;AACdL,MAAAA,UAAU,CAAC8C,mBAAX;AACAjD,MAAAA,KAAK,CAACsQ,wBAAN;AACD,KAHD,MAGO;AACLnQ,MAAAA,UAAU,CAAC6C,iBAAX;AACAhD,MAAAA,KAAK,CAACuQ,sBAAN;AACD;AACF,GARD,MAQO;AACL,QAAI/P,UAAJ,EAAgB;AACdL,MAAAA,UAAU,CAAC4C,gBAAX;AACAS,MAAAA,UAAU,CAACT,gBAAX;AACD,KAHD,MAGO;AACL5C,MAAAA,UAAU,CAAC2C,SAAX;AACAU,MAAAA,UAAU,CAACX,QAAX;AACD;AACF,GAzGD;;;AA4GAS,EAAAA,oBAAoB,CAClBtD,KADkB,EAElBQ,UAFkB,EAGlB+C,QAHkB,EAIlBtD,MAJkB,EAKlBV,MALkB,EAMlBY,UANkB,EAOlBqD,UAPkB,CAApB;AAUA,MAAIhD,UAAJ,EAAgBR,KAAK,CAACwQ,eAAN,GAAhB,KACKxQ,KAAK,CAACyQ,aAAN,GAvHL;;AA0HAL,EAAAA,SAAS,CAACzN,GAAV,GAAgBrC,IAAhB;AAEAN,EAAAA,KAAK,CAACsG,IAAN,CAAW,WAAX,EAAwB8J,SAAxB;AAEA,SAAO9P,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASoQ,SAAT,CACE1Q,KADF,EAEEkB,IAFF,EAGEiP,eAHF,EAIE3P,UAJF,EAKEF,IALF,EAMEL,MANF,EAOEV,MAPF,EAQEoC,UARF,EASEgP,SATF,EAUE;AACA;AACA,MAAI,CAACnQ,UAAD,IAAeR,KAAK,CAACE,IAAN,KAAe,YAAlC,EACE,MAAM,IAAIuC,eAAJ,iBACKvB,IADL,wIAAN;AAIF,MAAIV,UAAU,IAAIR,KAAK,CAACE,IAAN,KAAe,UAAjC,EACE,MAAM,IAAIuC,eAAJ,iBACKvB,IADL,sIAAN;;AAIF,MAAIS,UAAJ,EAAgB;AACd,QAAIgP,SAAJ,EAAe;AACb,UAAI,OAAOhP,UAAP,KAAsB,UAA1B,EACE,MAAM,IAAIU,0BAAJ,iBACKnB,IADL,wEACsES,UADtE,QAAN;AAGH,KALD,MAKO;AACL,UAAI,CAACd,aAAa,CAACc,UAAD,CAAlB,EACE,MAAM,IAAIU,0BAAJ,iBACKnB,IADL,iEAC+DS,UAD/D,QAAN;AAGH;AACF,GAxBD;;;AA2BA1B,EAAAA,MAAM,GAAG,KAAKA,MAAd;AACAV,EAAAA,MAAM,GAAG,KAAKA,MAAd;AAEA,MAAIiH,OAAJ;;AAEA,MAAImK,SAAJ,EAAe;AACbnK,IAAAA,OAAO,GAAG7E,UAAV;AACAA,IAAAA,UAAU,GAAGiP,SAAb;AACD;;AAED,MAAI,CAAC5Q,KAAK,CAAC8P,cAAP,IAAyB7P,MAAM,KAAKV,MAAxC,EACE,MAAM,IAAIkD,eAAJ,iBACKvB,IADL,+CAC6CjB,MAD7C,wGAAN;;AAIF,MAAIE,UAAU,GAAGH,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBJ,MAAjB,CAAjB;;AACA,MAAIuD,UAAU,GAAGxD,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBd,MAAjB,CAAjB;;AACA,MAAIgE,QAAJ,CA5CA;;AA+CA,MAAIsN,uBAAJ;;AAEA,MAAI,CAACV,eAAL,EAAsB;AACpB5M,IAAAA,QAAQ,GAAGvD,KAAK,CAAC+F,MAAN,CAAa1F,GAAb,CAAiBC,IAAjB,CAAX;;AAEA,QAAIiD,QAAJ,EAAc;AACZ;AACA;AACA,UACEA,QAAQ,CAACtD,MAAT,CAAgB0C,GAAhB,KAAwB1C,MAAxB,IACAsD,QAAQ,CAAChE,MAAT,CAAgBoD,GAAhB,KAAwBpD,MADxB,IAECiB,UAAU,KACR+C,QAAQ,CAACtD,MAAT,CAAgB0C,GAAhB,KAAwBpD,MAAxB,IAAkCgE,QAAQ,CAAChE,MAAT,CAAgBoD,GAAhB,KAAwB1C,MADlD,CAHb,EAKE;AACA,cAAM,IAAIwC,eAAJ,iBACKvB,IADL,qEACmEZ,IADnE,4BACuFL,MADvF,2BAC4GV,MAD5G,8BACoIgE,QAAQ,CAACtD,MAAT,CAAgB0C,GADpJ,mBAC8JY,QAAQ,CAAChE,MAAT,CAAgBoD,GAD9K,UAAN;AAGD;;AAEDkO,MAAAA,uBAAuB,GAAGtN,QAA1B;AACD;AACF,GApED;;;AAuEA,MAAI,CAACsN,uBAAD,IAA4B,CAAC7Q,KAAK,CAACyD,KAAnC,IAA4CtD,UAAhD,EAA4D;AAC1D0Q,IAAAA,uBAAuB,GAAGrQ,UAAU,GAChCL,UAAU,CAACK,UAAX,CAAsBjB,MAAtB,CADgC,GAEhCY,UAAU,CAACI,GAAX,CAAehB,MAAf,CAFJ;AAGD,GA3ED;;;AA8EA,MAAIsR,uBAAJ,EAA6B;AAC3B,QAAMC,IAAI,GAAG,CAACD,uBAAuB,CAAClO,GAAzB,EAA8B,KAA9B,EAAqC,KAArC,EAA4C,KAA5C,CAAb,CAD2B;;AAI3B,QAAIgO,SAAS,GAAG,CAACnK,OAAJ,GAAc,CAAC7E,UAA5B,EAAwC,OAAOmP,IAAP,CAJb;;AAO3B,QAAIH,SAAJ,EAAe;AACb,UAAMI,aAAa,GAAGF,uBAAuB,CAAClP,UAA9C;AACAkP,MAAAA,uBAAuB,CAAClP,UAAxB,GAAqC6E,OAAO,CAACuK,aAAD,CAA5C;AAEA/Q,MAAAA,KAAK,CAACsG,IAAN,CAAW,uBAAX,EAAoC;AAClCpG,QAAAA,IAAI,EAAE,SAD4B;AAElCyC,QAAAA,GAAG,EAAEkO,uBAAuB,CAAClO,GAFK;AAGlChB,QAAAA,UAAU,EAAEkP,uBAAuB,CAAClP;AAHF,OAApC;AAKD,KATD;AAAA,SAYK;AACH9B,MAAAA,MAAM,CAACgR,uBAAuB,CAAClP,UAAzB,EAAqCA,UAArC,CAAN;AAEA3B,MAAAA,KAAK,CAACsG,IAAN,CAAW,uBAAX,EAAoC;AAClCpG,QAAAA,IAAI,EAAE,OAD4B;AAElCyC,QAAAA,GAAG,EAAEkO,uBAAuB,CAAClO,GAFK;AAGlChB,QAAAA,UAAU,EAAEkP,uBAAuB,CAAClP,UAHF;AAIlCkD,QAAAA,IAAI,EAAElD;AAJ4B,OAApC;AAMD;;AAED,WAAOmP,IAAP;AACD;;AAEDnP,EAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B;AAEA,MAAIgP,SAAS,IAAInK,OAAjB,EAA0B7E,UAAU,GAAG6E,OAAO,CAAC7E,UAAD,CAApB,CAjH1B;;AAoHA,MAAMyO,SAAS,GAAG;AAChBzN,IAAAA,GAAG,EAAE,IADW;AAEhBnC,IAAAA,UAAU,EAAVA,UAFgB;AAGhBP,IAAAA,MAAM,EAANA,MAHgB;AAIhBV,IAAAA,MAAM,EAANA,MAJgB;AAKhBoC,IAAAA,UAAU,EAAVA;AALgB,GAAlB;;AAQA,MAAIwO,eAAJ,EAAqB;AACnB;AACA;AACA7P,IAAAA,IAAI,GAAGN,KAAK,CAACqQ,iBAAN,EAAP;AACD,GAJD,MAIO;AACL;AACA/P,IAAAA,IAAI,GAAG,KAAKA,IAAZ,CAFK;;AAKL,QAAIN,KAAK,CAAC+F,MAAN,CAAasF,GAAb,CAAiB/K,IAAjB,CAAJ,EACE,MAAM,IAAImC,eAAJ,iBACKvB,IADL,qBACmBZ,IADnB,0CAAN;AAGH;;AAED,MAAI0Q,cAAc,GAAG,KAArB;AACA,MAAIC,cAAc,GAAG,KAArB;;AAEA,MAAI,CAAC9Q,UAAL,EAAiB;AACfA,IAAAA,UAAU,GAAG8P,aAAa,CAACjQ,KAAD,EAAQC,MAAR,EAAgB,EAAhB,CAA1B;AACA+Q,IAAAA,cAAc,GAAG,IAAjB;;AAEA,QAAI/Q,MAAM,KAAKV,MAAf,EAAuB;AACrBiE,MAAAA,UAAU,GAAGrD,UAAb;AACA8Q,MAAAA,cAAc,GAAG,IAAjB;AACD;AACF;;AACD,MAAI,CAACzN,UAAL,EAAiB;AACfA,IAAAA,UAAU,GAAGyM,aAAa,CAACjQ,KAAD,EAAQT,MAAR,EAAgB,EAAhB,CAA1B;AACA0R,IAAAA,cAAc,GAAG,IAAjB;AACD,GA1JD;;;AA6JA1N,EAAAA,QAAQ,GAAG,IAAIF,QAAJ,CAAa7C,UAAb,EAAyBF,IAAzB,EAA+BH,UAA/B,EAA2CqD,UAA3C,EAAuD7B,UAAvD,CAAX,CA7JA;;AAgKA3B,EAAAA,KAAK,CAAC+F,MAAN,CAAa7B,GAAb,CAAiB5D,IAAjB,EAAuBiD,QAAvB,EAhKA;;;AAmKA,MAAItD,MAAM,KAAKV,MAAf,EAAuB;AACrB,QAAIiB,UAAJ,EAAgB;AACdL,MAAAA,UAAU,CAAC8C,mBAAX;AACAjD,MAAAA,KAAK,CAACsQ,wBAAN;AACD,KAHD,MAGO;AACLnQ,MAAAA,UAAU,CAAC6C,iBAAX;AACAhD,MAAAA,KAAK,CAACuQ,sBAAN;AACD;AACF,GARD,MAQO;AACL,QAAI/P,UAAJ,EAAgB;AACdL,MAAAA,UAAU,CAAC4C,gBAAX;AACAS,MAAAA,UAAU,CAACT,gBAAX;AACD,KAHD,MAGO;AACL5C,MAAAA,UAAU,CAAC2C,SAAX;AACAU,MAAAA,UAAU,CAACX,QAAX;AACD;AACF,GAnLD;;;AAsLAS,EAAAA,oBAAoB,CAClBtD,KADkB,EAElBQ,UAFkB,EAGlB+C,QAHkB,EAIlBtD,MAJkB,EAKlBV,MALkB,EAMlBY,UANkB,EAOlBqD,UAPkB,CAApB;AAUA,MAAIhD,UAAJ,EAAgBR,KAAK,CAACwQ,eAAN,GAAhB,KACKxQ,KAAK,CAACyQ,aAAN,GAjML;;AAoMAL,EAAAA,SAAS,CAACzN,GAAV,GAAgBrC,IAAhB;AAEAN,EAAAA,KAAK,CAACsG,IAAN,CAAW,WAAX,EAAwB8J,SAAxB;AAEA,SAAO,CAAC9P,IAAD,EAAO,IAAP,EAAa0Q,cAAb,EAA6BC,cAA7B,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACqBhK;;;AACnB,iBAAYiK,OAAZ,EAAqB;AAAA;;AACnB,6CADmB;;AAInBA,IAAAA,OAAO,GAAGrR,MAAM,CAAC,EAAD,EAAKgQ,QAAL,EAAeqB,OAAf,CAAhB,CAJmB;;AAOnB,QAAI,OAAOA,OAAO,CAACzN,KAAf,KAAyB,SAA7B,EACE,MAAM,IAAIpB,0BAAJ,oFACuE6O,OAAO,CAACzN,KAD/E,SAAN;AAIF,QAAI,CAAC+L,KAAK,CAACnE,GAAN,CAAU6F,OAAO,CAAChR,IAAlB,CAAL,EACE,MAAM,IAAImC,0BAAJ,0HACuG6O,OAAO,CAAChR,IAD/G,SAAN;AAIF,QAAI,OAAOgR,OAAO,CAACpB,cAAf,KAAkC,SAAtC,EACE,MAAM,IAAIzN,0BAAJ,6FACgF6O,OAAO,CAACpB,cADxF,SAAN,CAlBiB;AAwBnB;;AACA,QAAME,aAAa,GACjBkB,OAAO,CAAChR,IAAR,KAAiB,OAAjB,GACIwC,aADJ,GAEIwO,OAAO,CAAChR,IAAR,KAAiB,UAAjB,GACAgD,gBADA,GAEAE,kBALN;AAOAnC,IAAAA,eAAe,gCAAO,eAAP,EAAwB+O,aAAxB,CAAf,CAhCmB;AAoCnB;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA,QAAMmB,UAAU,GAAG5B,WAAW,EAA9B;AACA,QAAI6B,MAAM,GAAG,CAAb;;AAEA,QAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,GAAM;AAC7B,UAAIC,gBAAJ;;AAEA,SAAG;AACDA,QAAAA,gBAAgB,GAAG,UAAUH,UAAV,GAAuB,GAAvB,GAA6BC,MAAM,EAAtD;AACD,OAFD,QAES,MAAKrL,MAAL,CAAYsF,GAAZ,CAAgBiG,gBAAhB,CAFT;;AAIA,aAAOA,gBAAP;AACD,KARD,CAhDmB;;;AA2DnBrQ,IAAAA,eAAe,gCAAO,aAAP,EAAsB,EAAtB,CAAf;AACAA,IAAAA,eAAe,gCAAO,QAAP,EAAiB,IAAIsQ,GAAJ,EAAjB,CAAf;AACAtQ,IAAAA,eAAe,gCAAO,QAAP,EAAiB,IAAIsQ,GAAJ,EAAjB,CAAf;AACAtQ,IAAAA,eAAe,gCAAO,eAAP,EAAwB,CAAxB,CAAf;AACAA,IAAAA,eAAe,gCAAO,iBAAP,EAA0B,CAA1B,CAAf;AACAA,IAAAA,eAAe,gCAAO,wBAAP,EAAiC,CAAjC,CAAf;AACAA,IAAAA,eAAe,gCAAO,0BAAP,EAAmC,CAAnC,CAAf;AACAA,IAAAA,eAAe,gCAAO,mBAAP,EAA4BoQ,gBAA5B,CAAf,CAlEmB;;AAqEnBpQ,IAAAA,eAAe,gCAAO,UAAP,EAAmBiQ,OAAnB,CAAf,CArEmB;;AAwEnBzB,IAAAA,aAAa,CAAC7K,OAAd,CAAsB,UAAA4M,IAAI;AAAA,aAAIvQ,eAAe,gCAAOuQ,IAAP,EAAa,MAAKA,IAAL,CAAb,CAAnB;AAAA,KAA1B,EAxEmB;;AA2EnBjQ,IAAAA,gBAAgB,gCAAO,OAAP,EAAgB;AAAA,aAAM,MAAKnB,MAAL,CAAY+D,IAAlB;AAAA,KAAhB,CAAhB;AACA5C,IAAAA,gBAAgB,gCAAO,MAAP,EAAe;AAAA,aAAM,MAAKwE,MAAL,CAAY5B,IAAlB;AAAA,KAAf,CAAhB;AACA5C,IAAAA,gBAAgB,gCAAO,cAAP,EAAuB;AAAA,aAAM,MAAKkP,aAAX;AAAA,KAAvB,CAAhB;AACAlP,IAAAA,gBAAgB,gCAAO,gBAAP,EAAyB;AAAA,aAAM,MAAKiP,eAAX;AAAA,KAAzB,CAAhB;AACAjP,IAAAA,gBAAgB,gCAEd,eAFc,EAGd;AAAA,aAAM,MAAKgP,sBAAL,GAA8B,MAAKD,wBAAzC;AAAA,KAHc,CAAhB;AAKA/O,IAAAA,gBAAgB,gCAEd,uBAFc,EAGd;AAAA,aAAM,MAAKgP,sBAAX;AAAA,KAHc,CAAhB;AAKAhP,IAAAA,gBAAgB,gCAEd,yBAFc,EAGd;AAAA,aAAM,MAAK+O,wBAAX;AAAA,KAHc,CAAhB;AAKA/O,IAAAA,gBAAgB,gCAAO,OAAP,EAAgB,MAAKkQ,QAAL,CAAchO,KAA9B,CAAhB;AACAlC,IAAAA,gBAAgB,gCAAO,MAAP,EAAe,MAAKkQ,QAAL,CAAcvR,IAA7B,CAAhB;AACAqB,IAAAA,gBAAgB,gCAAO,gBAAP,EAAyB,MAAKkQ,QAAL,CAAc3B,cAAvC,CAAhB;AACAvO,IAAAA,gBAAgB,gCAAO,gBAAP,EAAyB;AAAA,aAAM,YAAN;AAAA,KAAzB,CAAhB;AAjGmB;AAkGpB;;;;SAEDmQ,yBAAA,kCAAyB;AACvB,SAAKjB,aAAL,GAAqB,CAArB;AACA,SAAKD,eAAL,GAAuB,CAAvB;AACA,SAAKD,sBAAL,GAA8B,CAA9B;AACA,SAAKD,wBAAL,GAAgC,CAAhC;AACD;AAED;AACF;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;;;SACEqB,UAAA,iBAAQ7M,IAAR,EAAc;AACZ,WAAO,KAAK1E,MAAL,CAAYiL,GAAZ,CAAgB,KAAKvG,IAArB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE8M,kBAAA,yBAAgB3R,MAAhB,EAAwBV,MAAxB,EAAgC;AAC9B;AACA,QAAI,KAAKW,IAAL,KAAc,YAAlB,EAAgC,OAAO,KAAP;;AAEhC,QAAIV,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,UAAMW,IAAI,GAAG,KAAKL,MAAlB;;AAEA,UAAMsD,QAAQ,GAAG,KAAKwC,MAAL,CAAY1F,GAAZ,CAAgBC,IAAhB,CAAjB;;AAEA,aAAO,CAAC,CAACiD,QAAF,IAAc,CAACA,QAAQ,CAAC/C,UAA/B;AACD,KAND,MAMO,IAAIhB,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AACjCM,MAAAA,MAAM,GAAG,KAAKA,MAAd;AACAV,MAAAA,MAAM,GAAG,KAAKA,MAAd,CAFiC;;AAKjC,UAAMqG,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;AAEA,UAAI,CAAC2F,QAAL,EAAe,OAAO,KAAP,CAPkB;;AAUjC,UAAMZ,KAAK,GAAGY,QAAQ,CAACrF,GAAT,CAAahB,MAAb,CAAd;AAEA,UAAI,CAACyF,KAAL,EAAY,OAAO,KAAP;AAEZ,aAAO,KAAKvB,KAAL,GAAa,CAAC,CAACuB,KAAK,CAACb,IAArB,GAA4B,IAAnC;AACD;;AAED,UAAM,IAAI9B,0BAAJ,iDACqC7C,SAAS,CAACG,MAD/C,0HAAN;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEkS,oBAAA,2BAAkB5R,MAAlB,EAA0BV,MAA1B,EAAkC;AAChC;AACA,QAAI,KAAKW,IAAL,KAAc,UAAlB,EAA8B,OAAO,KAAP;;AAE9B,QAAIV,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,UAAMW,IAAI,GAAG,KAAKL,MAAlB;;AAEA,UAAMsD,QAAQ,GAAG,KAAKwC,MAAL,CAAY1F,GAAZ,CAAgBC,IAAhB,CAAjB;;AAEA,aAAO,CAAC,CAACiD,QAAF,IAAcA,QAAQ,CAAC/C,UAA9B;AACD,KAND,MAMO,IAAIhB,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AACjCM,MAAAA,MAAM,GAAG,KAAKA,MAAd;AACAV,MAAAA,MAAM,GAAG,KAAKA,MAAd,CAFiC;;AAKjC,UAAMqG,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;AAEA,UAAI,CAAC2F,QAAL,EAAe,OAAO,KAAP,CAPkB;;AAUjC,UAAMZ,KAAK,GAAGY,QAAQ,CAACpF,UAAT,CAAoBjB,MAApB,CAAd;AAEA,UAAI,CAACyF,KAAL,EAAY,OAAO,KAAP;AAEZ,aAAO,KAAKvB,KAAL,GAAa,CAAC,CAACuB,KAAK,CAACb,IAArB,GAA4B,IAAnC;AACD;;AAED,UAAM,IAAI9B,0BAAJ,iDACqC7C,SAAS,CAACG,MAD/C,0HAAN;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEmS,UAAA,iBAAQ7R,MAAR,EAAgBV,MAAhB,EAAwB;AACtB,QAAIC,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,UAAMW,IAAI,GAAG,KAAKL,MAAlB;AAEA,aAAO,KAAK8F,MAAL,CAAYsF,GAAZ,CAAgB/K,IAAhB,CAAP;AACD,KAJD,MAIO,IAAId,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AACjCM,MAAAA,MAAM,GAAG,KAAKA,MAAd;AACAV,MAAAA,MAAM,GAAG,KAAKA,MAAd,CAFiC;;AAKjC,UAAMqG,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;AAEA,UAAI,CAAC2F,QAAL,EAAe,OAAO,KAAP,CAPkB;;AAUjC,UAAIZ,KAAK,GAAG,OAAOY,QAAQ,CAACrF,GAAhB,KAAwB,WAAxB,IAAuCqF,QAAQ,CAACrF,GAAT,CAAahB,MAAb,CAAnD;AAEA,UAAI,CAACyF,KAAL,EACEA,KAAK,GACH,OAAOY,QAAQ,CAACpF,UAAhB,KAA+B,WAA/B,IACAoF,QAAQ,CAACpF,UAAT,CAAoBjB,MAApB,CAFF;AAIF,UAAI,CAACyF,KAAL,EAAY,OAAO,KAAP;AAEZ,aAAO,KAAKvB,KAAL,GAAa,CAAC,CAACuB,KAAK,CAACb,IAArB,GAA4B,IAAnC;AACD;;AAED,UAAM,IAAI9B,0BAAJ,yCAC6B7C,SAAS,CAACG,MADvC,0HAAN;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEoS,eAAA,sBAAa9R,MAAb,EAAqBV,MAArB,EAA6B;AAC3B,QAAI,KAAKW,IAAL,KAAc,YAAlB,EAAgC;AAEhCD,IAAAA,MAAM,GAAG,KAAKA,MAAd;AACAV,IAAAA,MAAM,GAAG,KAAKA,MAAd;AAEA,QAAI,KAAKkE,KAAT,EACE,MAAM,IAAIhB,eAAJ,CACJ,0JADI,CAAN;;AAIF,QAAMtC,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;AAEA,QAAI,CAACE,UAAL,EACE,MAAM,IAAIqC,kBAAJ,oDACuCvC,MADvC,kCAAN;AAIF,QAAI,CAAC,KAAKG,MAAL,CAAYiL,GAAZ,CAAgB9L,MAAhB,CAAL,EACE,MAAM,IAAIiD,kBAAJ,oDACuCjD,MADvC,kCAAN;AAIF,QAAMgE,QAAQ,GAAIpD,UAAU,CAACI,GAAX,IAAkBJ,UAAU,CAACI,GAAX,CAAehB,MAAf,CAAnB,IAA8CqR,SAA/D;AAEA,QAAIrN,QAAJ,EAAc,OAAOA,QAAQ,CAACZ,GAAhB;AACf;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEqP,iBAAA,wBAAe/R,MAAf,EAAuBV,MAAvB,EAA+B;AAC7B,QAAI,KAAKW,IAAL,KAAc,UAAlB,EAA8B;AAE9BD,IAAAA,MAAM,GAAG,KAAKA,MAAd;AACAV,IAAAA,MAAM,GAAG,KAAKA,MAAd;AAEA,QAAI,KAAKkE,KAAT,EACE,MAAM,IAAIhB,eAAJ,CACJ,8JADI,CAAN;;AAIF,QAAMtC,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;AAEA,QAAI,CAACE,UAAL,EACE,MAAM,IAAIqC,kBAAJ,sDACyCvC,MADzC,kCAAN;AAIF,QAAI,CAAC,KAAKG,MAAL,CAAYiL,GAAZ,CAAgB9L,MAAhB,CAAL,EACE,MAAM,IAAIiD,kBAAJ,sDACyCjD,MADzC,kCAAN;AAIF,QAAMgE,QAAQ,GACXpD,UAAU,CAACK,UAAX,IAAyBL,UAAU,CAACK,UAAX,CAAsBjB,MAAtB,CAA1B,IAA4DqR,SAD9D;AAGA,QAAIrN,QAAJ,EAAc,OAAOA,QAAQ,CAACZ,GAAhB;AACf;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACErC,OAAA,cAAKL,MAAL,EAAaV,MAAb,EAAqB;AACnB,QAAI,KAAKkE,KAAT,EACE,MAAM,IAAIhB,eAAJ,CACJ,0IADI,CAAN;AAIFxC,IAAAA,MAAM,GAAG,KAAKA,MAAd;AACAV,IAAAA,MAAM,GAAG,KAAKA,MAAd;;AAEA,QAAMY,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;AAEA,QAAI,CAACE,UAAL,EACE,MAAM,IAAIqC,kBAAJ,4CAC+BvC,MAD/B,kCAAN;AAIF,QAAI,CAAC,KAAKG,MAAL,CAAYiL,GAAZ,CAAgB9L,MAAhB,CAAL,EACE,MAAM,IAAIiD,kBAAJ,4CAC+BjD,MAD/B,kCAAN;AAIF,QAAMgE,QAAQ,GACXpD,UAAU,CAACI,GAAX,IAAkBJ,UAAU,CAACI,GAAX,CAAehB,MAAf,CAAnB,IACCY,UAAU,CAACK,UAAX,IAAyBL,UAAU,CAACK,UAAX,CAAsBjB,MAAtB,CAD1B,IAEAqR,SAHF;AAKA,QAAIrN,QAAJ,EAAc,OAAOA,QAAQ,CAACZ,GAAhB;AACf;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEsP,uBAAA,8BAAqBnN,IAArB,EAA2BC,QAA3B,EAAqC;AACnCD,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AACAC,IAAAA,QAAQ,GAAG,KAAKA,QAAhB;;AAEA,QAAMa,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,4DAC+CsC,IAD/C,2BAAN;AAIF,QAAI,KAAK5E,IAAL,KAAc,YAAlB,EAAgC,OAAO,KAAP;AAEhC,WAAO6E,QAAQ,IAAIa,QAAQ,MAApB,IAA2Bb,QAAQ,IAAIa,QAAQ,CAACrF,GAAvD;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE2R,kBAAA,yBAAgBpN,IAAhB,EAAsBC,QAAtB,EAAgC;AAC9BD,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AACAC,IAAAA,QAAQ,GAAG,KAAKA,QAAhB;;AAEA,QAAMa,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,uDAC0CsC,IAD1C,2BAAN;AAIF,QAAI,KAAK5E,IAAL,KAAc,YAAlB,EAAgC,OAAO,KAAP;AAEhC,WAAO6E,QAAQ,IAAIa,QAAQ,CAACrF,GAA5B;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE4R,iBAAA,wBAAerN,IAAf,EAAqBC,QAArB,EAA+B;AAC7BD,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AACAC,IAAAA,QAAQ,GAAG,KAAKA,QAAhB;;AAEA,QAAMa,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,sDACyCsC,IADzC,2BAAN;AAIF,QAAI,KAAK5E,IAAL,KAAc,YAAlB,EAAgC,OAAO,KAAP;AAEhC,WAAO6E,QAAQ,IAAIa,QAAQ,MAA3B;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEwM,yBAAA,gCAAuBtN,IAAvB,EAA6BC,QAA7B,EAAuC;AACrCD,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AACAC,IAAAA,QAAQ,GAAG,KAAKA,QAAhB;;AAEA,QAAMa,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,8DACiDsC,IADjD,2BAAN;AAIF,QAAI,KAAK5E,IAAL,KAAc,UAAlB,EAA8B,OAAO,KAAP;AAE9B,WAAO6E,QAAQ,IAAIa,QAAQ,CAACpF,UAA5B;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE6R,eAAA,sBAAavN,IAAb,EAAmBC,QAAnB,EAA6B;AAC3BD,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AACAC,IAAAA,QAAQ,GAAG,KAAKA,QAAhB;;AAEA,QAAMa,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,oDACuCsC,IADvC,2BAAN;;AAIF,QAAI,KAAK5E,IAAL,KAAc,YAAlB,EAAgC;AAC9B,UAAI6E,QAAQ,IAAIa,QAAQ,MAApB,IAA2Bb,QAAQ,IAAIa,QAAQ,CAACrF,GAApD,EAAyD,OAAO,IAAP;AAC1D;;AAED,QAAI,KAAKL,IAAL,KAAc,UAAlB,EAA8B;AAC5B,UAAI6E,QAAQ,IAAIa,QAAQ,CAACpF,UAAzB,EAAqC,OAAO,IAAP;AACtC;;AAED,WAAO,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE8R,sBAAA,6BAAoBxN,IAApB,EAA0BC,QAA1B,EAAoC;AAClCD,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AACAC,IAAAA,QAAQ,GAAG,KAAKA,QAAhB;;AAEA,QAAMa,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,2DAC8CsC,IAD9C,2BAAN;;AAIF,QAAI,KAAK5E,IAAL,KAAc,YAAlB,EAAgC;AAC9B,UAAI6E,QAAQ,IAAIa,QAAQ,MAAxB,EAA6B,OAAO,IAAP;AAC9B;;AAED,QAAI,KAAK1F,IAAL,KAAc,UAAlB,EAA8B;AAC5B,UAAI6E,QAAQ,IAAIa,QAAQ,CAACpF,UAAzB,EAAqC,OAAO,IAAP;AACtC;;AAED,WAAO,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE+R,uBAAA,8BAAqBzN,IAArB,EAA2BC,QAA3B,EAAqC;AACnCD,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AACAC,IAAAA,QAAQ,GAAG,KAAKA,QAAhB;;AAEA,QAAMa,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,4DAC+CsC,IAD/C,2BAAN;;AAIF,QAAI,KAAK5E,IAAL,KAAc,YAAlB,EAAgC;AAC9B,UAAI6E,QAAQ,IAAIa,QAAQ,CAACrF,GAAzB,EAA8B,OAAO,IAAP;AAC/B;;AAED,QAAI,KAAKL,IAAL,KAAc,UAAlB,EAA8B;AAC5B,UAAI6E,QAAQ,IAAIa,QAAQ,CAACpF,UAAzB,EAAqC,OAAO,IAAP;AACtC;;AAED,WAAO,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEqC,WAAA,kBAASiC,IAAT,EAAe;AACbA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMc,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,gDACmCsC,IADnC,2BAAN;AAIF,QAAI,KAAK5E,IAAL,KAAc,YAAlB,EAAgC,OAAO,CAAP;AAEhC,WAAO0F,QAAQ,CAAC/C,QAAT,GAAoB+C,QAAQ,CAAC5C,iBAApC;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEF,YAAA,mBAAUgC,IAAV,EAAgB;AACdA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMc,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,iDACoCsC,IADpC,2BAAN;AAIF,QAAI,KAAK5E,IAAL,KAAc,YAAlB,EAAgC,OAAO,CAAP;AAEhC,WAAO0F,QAAQ,CAAC9C,SAAT,GAAqB8C,QAAQ,CAAC5C,iBAArC;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEwP,iBAAA,wBAAe1N,IAAf,EAAqB;AACnBA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMc,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,sDACyCsC,IADzC,2BAAN;AAIF,QAAI,KAAK5E,IAAL,KAAc,YAAlB,EAAgC,OAAO,CAAP;AAEhC,QAAMuS,KAAK,GAAG7M,QAAQ,CAAC5C,iBAAvB;AAEA,QAAMH,QAAQ,GAAG+C,QAAQ,CAAC/C,QAAT,GAAoB4P,KAArC;AACA,QAAM3P,SAAS,GAAG8C,QAAQ,CAAC9C,SAAT,GAAqB2P,KAAvC;AAEA,WAAO5P,QAAQ,GAAGC,SAAlB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEC,mBAAA,0BAAiB+B,IAAjB,EAAuB;AACrBA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMc,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,wDAC2CsC,IAD3C,2BAAN;AAIF,QAAI,KAAK5E,IAAL,KAAc,UAAlB,EAA8B,OAAO,CAAP;AAE9B,QAAMuS,KAAK,GAAG7M,QAAQ,CAAC3C,mBAAvB;AAEA,WAAO2C,QAAQ,CAAC7C,gBAAT,GAA4B0P,KAAK,GAAG,CAA3C;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEC,SAAA,gBAAO5N,IAAP,EAAa;AACXA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMc,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,8CACiCsC,IADjC,2BAAN;AAIF,QAAI4N,MAAM,GAAG,CAAb;;AAEA,QAAI,KAAKxS,IAAL,KAAc,UAAlB,EAA8B;AAC5BwS,MAAAA,MAAM,IAAI9M,QAAQ,CAAC7C,gBAAT,GAA4B6C,QAAQ,CAAC3C,mBAAT,GAA+B,CAArE;AACD;;AAED,QAAI,KAAK/C,IAAL,KAAc,YAAlB,EAAgC;AAC9BwS,MAAAA,MAAM,IACJ9M,QAAQ,CAAC/C,QAAT,GAAoB+C,QAAQ,CAAC9C,SAA7B,GAAyC8C,QAAQ,CAAC5C,iBAAT,GAA6B,CADxE;AAED;;AAED,WAAO0P,MAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEC,2BAAA,kCAAyB7N,IAAzB,EAA+B;AAC7BA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMc,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,gEACmDsC,IADnD,2BAAN;AAIF,QAAI,KAAK5E,IAAL,KAAc,YAAlB,EAAgC,OAAO,CAAP;AAEhC,WAAO0F,QAAQ,CAAC/C,QAAhB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE+P,4BAAA,mCAA0B9N,IAA1B,EAAgC;AAC9BA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMc,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,iEACoDsC,IADpD,2BAAN;AAIF,QAAI,KAAK5E,IAAL,KAAc,YAAlB,EAAgC,OAAO,CAAP;AAEhC,WAAO0F,QAAQ,CAAC9C,SAAhB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE+P,iCAAA,wCAA+B/N,IAA/B,EAAqC;AACnCA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMc,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,sEACyDsC,IADzD,2BAAN;AAIF,QAAI,KAAK5E,IAAL,KAAc,YAAlB,EAAgC,OAAO,CAAP;AAEhC,WAAO0F,QAAQ,CAAC/C,QAAT,GAAoB+C,QAAQ,CAAC9C,SAApC;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEgQ,mCAAA,0CAAiChO,IAAjC,EAAuC;AACrCA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMc,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,wEAC2DsC,IAD3D,2BAAN;AAIF,QAAI,KAAK5E,IAAL,KAAc,UAAlB,EAA8B,OAAO,CAAP;AAE9B,WAAO0F,QAAQ,CAAC7C,gBAAhB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEgQ,yBAAA,gCAAuBjO,IAAvB,EAA6B;AAC3BA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMc,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,8DACiDsC,IADjD,2BAAN;AAIF,QAAI4N,MAAM,GAAG,CAAb;;AAEA,QAAI,KAAKxS,IAAL,KAAc,UAAlB,EAA8B;AAC5BwS,MAAAA,MAAM,IAAI9M,QAAQ,CAAC7C,gBAAnB;AACD;;AAED,QAAI,KAAK7C,IAAL,KAAc,YAAlB,EAAgC;AAC9BwS,MAAAA,MAAM,IAAI9M,QAAQ,CAAC/C,QAAT,GAAoB+C,QAAQ,CAAC9C,SAAvC;AACD;;AAED,WAAO4P,MAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEzS,SAAA,gBAAOK,IAAP,EAAa;AACXA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMuE,IAAI,GAAG,KAAKkB,MAAL,CAAY1F,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAACuE,IAAL,EACE,MAAM,IAAIrC,kBAAJ,8CACiClC,IADjC,2BAAN;AAIF,WAAOuE,IAAI,CAAC5E,MAAL,CAAY0C,GAAnB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEpD,SAAA,gBAAOe,IAAP,EAAa;AACXA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMuE,IAAI,GAAG,KAAKkB,MAAL,CAAY1F,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAACuE,IAAL,EACE,MAAM,IAAIrC,kBAAJ,8CACiClC,IADjC,2BAAN;AAIF,WAAOuE,IAAI,CAACtF,MAAL,CAAYoD,GAAnB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEqQ,cAAA,qBAAY1S,IAAZ,EAAkB;AAChBA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMiD,QAAQ,GAAG,KAAKwC,MAAL,CAAY1F,GAAZ,CAAgBC,IAAhB,CAAjB;;AAEA,QAAI,CAACiD,QAAL,EACE,MAAM,IAAIf,kBAAJ,mDACsClC,IADtC,2BAAN;AAIF,WAAO,CAACiD,QAAQ,CAACtD,MAAT,CAAgB0C,GAAjB,EAAsBY,QAAQ,CAAChE,MAAT,CAAgBoD,GAAtC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEsQ,WAAA,kBAASnO,IAAT,EAAexE,IAAf,EAAqB;AACnBwE,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AACAxE,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMuE,IAAI,GAAG,KAAKkB,MAAL,CAAY1F,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAACuE,IAAL,EACE,MAAM,IAAIrC,kBAAJ,gDACmClC,IADnC,2BAAN;AAIF,QAAML,MAAM,GAAG4E,IAAI,CAAC5E,MAAL,CAAY0C,GAA3B;AACA,QAAMpD,MAAM,GAAGsF,IAAI,CAACtF,MAAL,CAAYoD,GAA3B;AAEA,QAAImC,IAAI,KAAK7E,MAAb,EAAqB,OAAOV,MAAP;AACrB,QAAIuF,IAAI,KAAKvF,MAAb,EAAqB,OAAOU,MAAP;AAErB,UAAM,IAAIuC,kBAAJ,iCACoBsC,IADpB,8CAC0DxE,IAD1D,sBACyEL,MADzE,eACoFV,MADpF,QAAN;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE2T,eAAA,sBAAa5S,IAAb,EAAmBwE,IAAnB,EAAyB;AACvBxE,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AACAwE,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMD,IAAI,GAAG,KAAKkB,MAAL,CAAY1F,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAACuE,IAAL,EACE,MAAM,IAAIrC,kBAAJ,oDACuClC,IADvC,2BAAN;AAIF,WAAOuE,IAAI,CAAC5E,MAAL,CAAY0C,GAAZ,KAAoBmC,IAApB,IAA4BD,IAAI,CAACtF,MAAL,CAAYoD,GAAZ,KAAoBmC,IAAvD;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEqO,eAAA,sBAAa7S,IAAb,EAAmB;AACjBA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMuE,IAAI,GAAG,KAAKkB,MAAL,CAAY1F,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAACuE,IAAL,EACE,MAAM,IAAIrC,kBAAJ,oDACuClC,IADvC,2BAAN;AAIF,WAAOuE,IAAI,CAACrE,UAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE4S,aAAA,oBAAW9S,IAAX,EAAiB;AACfA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMuE,IAAI,GAAG,KAAKkB,MAAL,CAAY1F,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAACuE,IAAL,EACE,MAAM,IAAIrC,kBAAJ,kDACqClC,IADrC,2BAAN;AAIF,WAAO,CAACuE,IAAI,CAACrE,UAAb;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE6S,aAAA,oBAAW/S,IAAX,EAAiB;AACfA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMuE,IAAI,GAAG,KAAKkB,MAAL,CAAY1F,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAACuE,IAAL,EACE,MAAM,IAAIrC,kBAAJ,kDACqClC,IADrC,2BAAN;AAIF,WAAOuE,IAAI,CAAC5E,MAAL,KAAgB4E,IAAI,CAACtF,MAA5B;AACD;AAED;AACF;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEwQ,UAAA,iBAAQjL,IAAR,EAAcnD,UAAd,EAA0B;AACxB,QAAMiE,QAAQ,GAAGmK,QAAO,CAAC,IAAD,EAAOjL,IAAP,EAAanD,UAAb,CAAxB;;AAEA,WAAOiE,QAAQ,CAACjD,GAAhB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;SACE2Q,YAAA,mBAAUxO,IAAV,EAAgBnD,UAAhB,EAA4B;AAC1B,QAAIA,UAAU,IAAI,CAACd,aAAa,CAACc,UAAD,CAAhC,EACE,MAAM,IAAIU,0BAAJ,8EACiEV,UADjE,QAAN,CAFwB;;AAO1BmD,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AACAnD,IAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B,CAR0B;;AAW1B,QAAIkD,IAAI,GAAG,KAAKzE,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAX;;AAEA,QAAID,IAAJ,EAAU;AACR,UAAIlD,UAAJ,EAAgB;AACd9B,QAAAA,MAAM,CAACgF,IAAI,CAAClD,UAAN,EAAkBA,UAAlB,CAAN;AAEA,aAAK2E,IAAL,CAAU,uBAAV,EAAmC;AACjCpG,UAAAA,IAAI,EAAE,OAD2B;AAEjCyC,UAAAA,GAAG,EAAEmC,IAF4B;AAGjCnD,UAAAA,UAAU,EAAEkD,IAAI,CAAClD,UAHgB;AAIjCkD,UAAAA,IAAI,EAAElD;AAJ2B,SAAnC;AAMD;;AACD,aAAO,CAACmD,IAAD,EAAO,KAAP,CAAP;AACD;;AAEDD,IAAAA,IAAI,GAAG,IAAI,KAAKmL,aAAT,CAAuBlL,IAAvB,EAA6BnD,UAA7B,CAAP,CA3B0B;;AA8B1B,SAAKvB,MAAL,CAAY8D,GAAZ,CAAgBY,IAAhB,EAAsBD,IAAtB,EA9B0B;;;AAiC1B,SAAKyB,IAAL,CAAU,WAAV,EAAuB;AACrB3D,MAAAA,GAAG,EAAEmC,IADgB;AAErBnD,MAAAA,UAAU,EAAVA;AAFqB,KAAvB;AAKA,WAAO,CAACmD,IAAD,EAAO,IAAP,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEyO,aAAA,oBAAWzO,IAAX,EAAiB0B,OAAjB,EAA0B;AACxB,QAAIA,OAAO,IAAI,OAAOA,OAAP,KAAmB,UAAlC,EACE,MAAM,IAAInE,0BAAJ,sFACyEmE,OADzE,QAAN,CAFsB;;AAOxB1B,IAAAA,IAAI,GAAG,KAAKA,IAAZ,CAPwB;;AAUxB,QAAID,IAAI,GAAG,KAAKzE,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAX;;AAEA,QAAID,IAAJ,EAAU;AACR,UAAI2B,OAAJ,EAAa;AACX,YAAMuK,aAAa,GAAGlM,IAAI,CAAClD,UAA3B;AACAkD,QAAAA,IAAI,CAAClD,UAAL,GAAkB6E,OAAO,CAACuK,aAAD,CAAzB;AAEA,aAAKzK,IAAL,CAAU,uBAAV,EAAmC;AACjCpG,UAAAA,IAAI,EAAE,SAD2B;AAEjCyC,UAAAA,GAAG,EAAEmC,IAF4B;AAGjCnD,UAAAA,UAAU,EAAEkD,IAAI,CAAClD;AAHgB,SAAnC;AAKD;;AACD,aAAO,CAACmD,IAAD,EAAO,KAAP,CAAP;AACD;;AAED,QAAMnD,UAAU,GAAG6E,OAAO,GAAGA,OAAO,CAAC,EAAD,CAAV,GAAiB,EAA3C;AAEA3B,IAAAA,IAAI,GAAG,IAAI,KAAKmL,aAAT,CAAuBlL,IAAvB,EAA6BnD,UAA7B,CAAP,CA5BwB;;AA+BxB,SAAKvB,MAAL,CAAY8D,GAAZ,CAAgBY,IAAhB,EAAsBD,IAAtB,EA/BwB;;;AAkCxB,SAAKyB,IAAL,CAAU,WAAV,EAAuB;AACrB3D,MAAAA,GAAG,EAAEmC,IADgB;AAErBnD,MAAAA,UAAU,EAAVA;AAFqB,KAAvB;AAKA,WAAO,CAACmD,IAAD,EAAO,IAAP,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACElE,WAAA,kBAASkE,IAAT,EAAe;AAAA;;AACbA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMc,QAAQ,GAAG,KAAKxF,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAjB;;AAEA,QAAI,CAACc,QAAL,EACE,MAAM,IAAIpD,kBAAJ,gDACmCsC,IADnC,2BAAN,CANW;AAWb;;AACA,SAAKmF,WAAL,CAAiBnF,IAAjB,EAAuB,UAAAxE,IAAI,EAAI;AAC7B,MAAA,MAAI,CAACkT,QAAL,CAAclT,IAAd;AACD,KAFD,EAZa;;AAiBb,SAAKF,MAAL,WAAmB0E,IAAnB,EAjBa;;;AAoBb,SAAKwB,IAAL,CAAU,aAAV,EAAyB;AACvB3D,MAAAA,GAAG,EAAEmC,IADkB;AAEvBnD,MAAAA,UAAU,EAAEiE,QAAQ,CAACjE;AAFE,KAAzB;AAID;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE6R,WAAA,kBAASlT,IAAT,EAAe;AACb,QAAIiD,QAAJ;;AAEA,QAAI/D,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;AACxB,UAAMM,MAAM,GAAG,KAAKT,SAAS,CAAC,CAAD,CAA7B;AAAA,UACED,MAAM,GAAG,KAAKC,SAAS,CAAC,CAAD,CADzB;AAGA+D,MAAAA,QAAQ,GAAGxD,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeV,MAAf,EAAuB,KAAKW,IAA5B,CAA1B;AAEA,UAAI,CAACqD,QAAL,EACE,MAAM,IAAIf,kBAAJ,gDACmCvC,MADnC,qBACkDV,MADlD,2BAAN;AAGH,KAVD,MAUO;AACLe,MAAAA,IAAI,GAAG,KAAKA,IAAZ;AAEAiD,MAAAA,QAAQ,GAAG,KAAKwC,MAAL,CAAY1F,GAAZ,CAAgBC,IAAhB,CAAX;AAEA,UAAI,CAACiD,QAAL,EACE,MAAM,IAAIf,kBAAJ,gDACmClC,IADnC,2BAAN;AAGH,KAtBY;;;AAyBb,SAAKyF,MAAL,WAAmBxC,QAAQ,CAACZ,GAA5B,EAzBa;;;AA4Bb,oBAA6DY,QAA7D;AAAA,QAAepD,UAAf,aAAOF,MAAP;AAAA,QAAmCuD,UAAnC,aAA2BjE,MAA3B;AAAA,QAA+CoC,UAA/C,aAA+CA,UAA/C;AAEA,QAAMnB,UAAU,GAAG+C,QAAQ,CAAC/C,UAA5B;;AAEA,QAAIL,UAAU,KAAKqD,UAAnB,EAA+B;AAC7B,UAAIhD,UAAJ,EAAgB;AACdL,QAAAA,UAAU,CAAC8C,mBAAX;AACA,aAAKqN,wBAAL;AACD,OAHD,MAGO;AACLnQ,QAAAA,UAAU,CAAC6C,iBAAX;AACA,aAAKuN,sBAAL;AACD;AACF,KARD,MAQO;AACL,UAAI/P,UAAJ,EAAgB;AACdL,QAAAA,UAAU,CAAC4C,gBAAX;AACAS,QAAAA,UAAU,CAACT,gBAAX;AACD,OAHD,MAGO;AACL5C,QAAAA,UAAU,CAAC2C,SAAX;AACAU,QAAAA,UAAU,CAACX,QAAX;AACD;AACF,KAhDY;;;AAmDbmB,IAAAA,2BAA2B,CAAC,IAAD,EAAOxD,UAAP,EAAmB+C,QAAnB,CAA3B;AAEA,QAAI/C,UAAJ,EAAgB,KAAKgQ,eAAL,GAAhB,KACK,KAAKC,aAAL,GAtDQ;;AAyDb,SAAKnK,IAAL,CAAU,aAAV,EAAyB;AACvB3D,MAAAA,GAAG,EAAErC,IADkB;AAEvBqB,MAAAA,UAAU,EAAVA,UAFuB;AAGvB1B,MAAAA,MAAM,EAAEE,UAAU,CAACwC,GAHI;AAIvBpD,MAAAA,MAAM,EAAEiE,UAAU,CAACb,GAJI;AAKvBnC,MAAAA,UAAU,EAAVA;AALuB,KAAzB;AAQA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;SACEoC,QAAA,iBAAQ;AACN;AACA,SAAKmD,MAAL,CAAYnD,KAAZ,GAFM;;;AAKN,SAAKxC,MAAL,CAAYwC,KAAZ,GALM;;;AAQN,SAAK8O,sBAAL,GARM;;;AAWN,SAAKpL,IAAL,CAAU,SAAV;AACD;AAED;AACF;AACA;AACA;AACA;;;SACEmN,aAAA,sBAAa;AACXpP,IAAAA,mBAAmB,CAAC,IAAD,CAAnB,CADW;;AAIX,SAAK0B,MAAL,CAAYnD,KAAZ,GAJW;;;AAOX,SAAK8O,sBAAL,GAPW;;;AAUX,SAAKpL,IAAL,CAAU,cAAV;AACD;AAED;AACF;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;;;SACEoN,eAAA,sBAAaxS,IAAb,EAAmB;AACjB,WAAO,KAAKyS,WAAL,CAAiBzS,IAAjB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;SACE0S,gBAAA,yBAAgB;AACd,WAAO,KAAKD,WAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;SACEE,eAAA,sBAAa3S,IAAb,EAAmB;AACjB,WAAO,KAAKyS,WAAL,CAAiBvN,cAAjB,CAAgClF,IAAhC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;SACE4S,eAAA,sBAAa5S,IAAb,EAAmBR,KAAnB,EAA0B;AACxB,SAAKiT,WAAL,CAAiBzS,IAAjB,IAAyBR,KAAzB,CADwB;;AAIxB,SAAK4F,IAAL,CAAU,mBAAV,EAA+B;AAC7BpG,MAAAA,IAAI,EAAE,KADuB;AAE7ByB,MAAAA,UAAU,EAAE,KAAKgS,WAFY;AAG7BzS,MAAAA,IAAI,EAAJA;AAH6B,KAA/B;AAMA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;SACE6S,kBAAA,yBAAgB7S,IAAhB,EAAsBsF,OAAtB,EAA+B;AAC7B,QAAI,OAAOA,OAAP,KAAmB,UAAvB,EACE,MAAM,IAAInE,0BAAJ,CACJ,sDADI,CAAN;AAIF,QAAM3B,KAAK,GAAG,KAAKiT,WAAL,CAAiBzS,IAAjB,CAAd;AAEA,SAAKyS,WAAL,CAAiBzS,IAAjB,IAAyBsF,OAAO,CAAC9F,KAAD,CAAhC,CAR6B;;AAW7B,SAAK4F,IAAL,CAAU,mBAAV,EAA+B;AAC7BpG,MAAAA,IAAI,EAAE,KADuB;AAE7ByB,MAAAA,UAAU,EAAE,KAAKgS,WAFY;AAG7BzS,MAAAA,IAAI,EAAJA;AAH6B,KAA/B;AAMA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;SACE8S,kBAAA,yBAAgB9S,IAAhB,EAAsB;AACpB,WAAO,KAAKyS,WAAL,CAAiBzS,IAAjB,CAAP,CADoB;;AAIpB,SAAKoF,IAAL,CAAU,mBAAV,EAA+B;AAC7BpG,MAAAA,IAAI,EAAE,QADuB;AAE7ByB,MAAAA,UAAU,EAAE,KAAKgS,WAFY;AAG7BzS,MAAAA,IAAI,EAAJA;AAH6B,KAA/B;AAMA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE+S,oBAAA,2BAAkBtS,UAAlB,EAA8B;AAC5B,QAAI,CAACd,aAAa,CAACc,UAAD,CAAlB,EACE,MAAM,IAAIU,0BAAJ,CACJ,sEADI,CAAN;AAIF,SAAKsR,WAAL,GAAmBhS,UAAnB,CAN4B;;AAS5B,SAAK2E,IAAL,CAAU,mBAAV,EAA+B;AAC7BpG,MAAAA,IAAI,EAAE,SADuB;AAE7ByB,MAAAA,UAAU,EAAE,KAAKgS;AAFY,KAA/B;AAKA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEO,kBAAA,yBAAgBvS,UAAhB,EAA4B;AAC1B,QAAI,CAACd,aAAa,CAACc,UAAD,CAAlB,EACE,MAAM,IAAIU,0BAAJ,CACJ,oEADI,CAAN;AAIFxC,IAAAA,MAAM,CAAC,KAAK8T,WAAN,EAAmBhS,UAAnB,CAAN,CAN0B;;AAS1B,SAAK2E,IAAL,CAAU,mBAAV,EAA+B;AAC7BpG,MAAAA,IAAI,EAAE,OADuB;AAE7ByB,MAAAA,UAAU,EAAE,KAAKgS,WAFY;AAG7B9O,MAAAA,IAAI,EAAElD;AAHuB,KAA/B;AAMA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEwS,mBAAA,0BAAiB3N,OAAjB,EAA0B;AACxB,QAAI,OAAOA,OAAP,KAAmB,UAAvB,EACE,MAAM,IAAInE,0BAAJ,CACJ,6DADI,CAAN;AAIF,SAAKsR,WAAL,GAAmBnN,OAAO,CAAC,KAAKmN,WAAN,CAA1B,CANwB;;AASxB,SAAKrN,IAAL,CAAU,mBAAV,EAA+B;AAC7BpG,MAAAA,IAAI,EAAE,QADuB;AAE7ByB,MAAAA,UAAU,EAAE,KAAKgS;AAFY,KAA/B;AAKA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;SACES,2BAAA,kCAAyB5N,OAAzB,EAAkC9E,KAAlC,EAAyC;AACvC,QAAI,OAAO8E,OAAP,KAAmB,UAAvB,EACE,MAAM,IAAInE,0BAAJ,CACJ,gEADI,CAAN;AAIF,QAAIX,KAAK,IAAI,CAACD,aAAa,CAACC,KAAD,CAA3B,EACE,MAAM,IAAIW,0BAAJ,CACJ,wHADI,CAAN;;AAIF,QAAMiC,QAAQ,GAAG,KAAKlE,MAAL,CAAYmE,MAAZ,EAAjB;;AAEA,QAAIC,IAAJ,EAAUoB,QAAV;;AAEA,WAASpB,IAAI,GAAGF,QAAQ,CAACG,IAAT,EAAR,EAA0BD,IAAI,CAACE,IAAL,KAAc,IAAhD,EAAuD;AACrDkB,MAAAA,QAAQ,GAAGpB,IAAI,CAAC9D,KAAhB;AACAkF,MAAAA,QAAQ,CAACjE,UAAT,GAAsB6E,OAAO,CAACZ,QAAQ,CAACjD,GAAV,EAAeiD,QAAQ,CAACjE,UAAxB,CAA7B;AACD;;AAED,SAAK2E,IAAL,CAAU,2BAAV,EAAuC;AACrC5E,MAAAA,KAAK,EAAEA,KAAK,GAAGA,KAAH,GAAW;AADc,KAAvC;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;;;SACE2S,2BAAA,kCAAyB7N,OAAzB,EAAkC9E,KAAlC,EAAyC;AACvC,QAAI,OAAO8E,OAAP,KAAmB,UAAvB,EACE,MAAM,IAAInE,0BAAJ,CACJ,gEADI,CAAN;AAIF,QAAIX,KAAK,IAAI,CAACD,aAAa,CAACC,KAAD,CAA3B,EACE,MAAM,IAAIW,0BAAJ,CACJ,wHADI,CAAN;;AAIF,QAAMiC,QAAQ,GAAG,KAAKyB,MAAL,CAAYxB,MAAZ,EAAjB;;AAEA,QAAIC,IAAJ,EAAUjB,QAAV,EAAoBpD,UAApB,EAAgCqD,UAAhC;;AAEA,WAASgB,IAAI,GAAGF,QAAQ,CAACG,IAAT,EAAR,EAA0BD,IAAI,CAACE,IAAL,KAAc,IAAhD,EAAuD;AACrDnB,MAAAA,QAAQ,GAAGiB,IAAI,CAAC9D,KAAhB;AACAP,MAAAA,UAAU,GAAGoD,QAAQ,CAACtD,MAAtB;AACAuD,MAAAA,UAAU,GAAGD,QAAQ,CAAChE,MAAtB;AAEAgE,MAAAA,QAAQ,CAAC5B,UAAT,GAAsB6E,OAAO,CAC3BjD,QAAQ,CAACZ,GADkB,EAE3BY,QAAQ,CAAC5B,UAFkB,EAG3BxB,UAAU,CAACwC,GAHgB,EAI3Ba,UAAU,CAACb,GAJgB,EAK3BxC,UAAU,CAACwB,UALgB,EAM3B6B,UAAU,CAAC7B,UANgB,EAO3B4B,QAAQ,CAAC/C,UAPkB,CAA7B;AASD;;AAED,SAAK8F,IAAL,CAAU,2BAAV,EAAuC;AACrC5E,MAAAA,KAAK,EAAEA,KAAK,GAAGA,KAAH,GAAW;AADc,KAAvC;AAGD;AAED;AACF;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;;;SACE4S,wBAAA,+BAAsBlM,QAAtB,EAAgC;AAC9B,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAI/F,0BAAJ,CACJ,oDADI,CAAN;AAIF,QAAI,KAAKoB,KAAT,EAAgBuL,qBAAqB,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,EAAsB,IAAtB,EAA4B5G,QAA5B,CAArB,CAAhB,KACKuG,sBAAsB,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,EAAsB,IAAtB,EAA4BvG,QAA5B,CAAtB;AACN;;SACDmM,mCAAA,0CAAiCnM,QAAjC,EAA2C;AACzC,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAI/F,0BAAJ,CACJ,+DADI,CAAN;AAIF,QAAI,KAAKoB,KAAT,EAAgBuL,qBAAqB,CAAC,KAAD,EAAQ,KAAR,EAAe,IAAf,EAAqB,IAArB,EAA2B5G,QAA3B,CAArB,CAAhB,KACKuG,sBAAsB,CAAC,KAAD,EAAQ,KAAR,EAAe,IAAf,EAAqB,IAArB,EAA2BvG,QAA3B,CAAtB;AACN;AAED;AACF;AACA;AACA;AACA;;;SACEoM,kCAAA,yCAAgCpM,QAAhC,EAA0C;AACxC,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAI/F,0BAAJ,CACJ,8DADI,CAAN;AAIF,QAAI,KAAKoB,KAAT,EAAgBuL,qBAAqB,CAAC,KAAD,EAAQ,IAAR,EAAc,KAAd,EAAqB,IAArB,EAA2B5G,QAA3B,CAArB,CAAhB,KACKuG,sBAAsB,CAAC,KAAD,EAAQ,IAAR,EAAc,KAAd,EAAqB,IAArB,EAA2BvG,QAA3B,CAAtB;AACN;;SACDqM,6CAAA,oDAA2CrM,QAA3C,EAAqD;AACnD,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAI/F,0BAAJ,CACJ,yEADI,CAAN;AAIF,QAAI,KAAKoB,KAAT,EAAgBuL,qBAAqB,CAAC,KAAD,EAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB,EAA0B5G,QAA1B,CAArB,CAAhB,KACKuG,sBAAsB,CAAC,KAAD,EAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB,EAA0BvG,QAA1B,CAAtB;AACN;AAED;AACF;AACA;AACA;AACA;;;SACEsM,QAAA,iBAAQ;AACN,QAAI,OAAO9S,KAAK,CAAC+H,IAAb,KAAsB,UAA1B,EAAsC,OAAO/H,KAAK,CAAC+H,IAAN,CAAW,KAAKvJ,MAAL,CAAYuI,IAAZ,EAAX,CAAP;AAEtC,WAAOiB,wBAAI,CAAC,KAAKxJ,MAAL,CAAYuI,IAAZ,EAAD,EAAqB,KAAKvI,MAAL,CAAY+D,IAAjC,CAAX;AACD;AAED;AACF;AACA;AACA;AACA;;;SACEwQ,cAAA,qBAAYvM,QAAZ,EAAsB;AACpB,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAI/F,0BAAJ,CACJ,0CADI,CAAN;;AAIF,QAAMiC,QAAQ,GAAG,KAAKlE,MAAL,CAAYmE,MAAZ,EAAjB;;AAEA,QAAIC,IAAJ,EAAUoB,QAAV;;AAEA,WAASpB,IAAI,GAAGF,QAAQ,CAACG,IAAT,EAAR,EAA0BD,IAAI,CAACE,IAAL,KAAc,IAAhD,EAAuD;AACrDkB,MAAAA,QAAQ,GAAGpB,IAAI,CAAC9D,KAAhB;AACA0H,MAAAA,QAAQ,CAACxC,QAAQ,CAACjD,GAAV,EAAeiD,QAAQ,CAACjE,UAAxB,CAAR;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;SACEiT,WAAA,kBAASxM,QAAT,EAAmB;AACjB,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAI/F,0BAAJ,CACJ,uCADI,CAAN;;AAIF,QAAMiC,QAAQ,GAAG,KAAKlE,MAAL,CAAYmE,MAAZ,EAAjB;;AAEA,QAAIC,IAAJ,EAAUoB,QAAV;;AAEA,WAASpB,IAAI,GAAGF,QAAQ,CAACG,IAAT,EAAR,EAA0BD,IAAI,CAACE,IAAL,KAAc,IAAhD,EAAuD;AACrDkB,MAAAA,QAAQ,GAAGpB,IAAI,CAAC9D,KAAhB;AAEA,UAAI0H,QAAQ,CAACxC,QAAQ,CAACjD,GAAV,EAAeiD,QAAQ,CAACjE,UAAxB,CAAZ,EAAiD,OAAOiE,QAAQ,CAACjD,GAAhB;AAClD;;AAED;AACD;AAED;AACF;AACA;AACA;AACA;;;SACEkS,WAAA,kBAASzM,QAAT,EAAmB;AACjB,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAI/F,0BAAJ,CACJ,sCADI,CAAN;;AAIF,QAAMiC,QAAQ,GAAG,KAAKlE,MAAL,CAAYmE,MAAZ,EAAjB;;AAEA,QAAIC,IAAJ,EAAUoB,QAAV;AAEA,QAAMkG,MAAM,GAAG,IAAIlK,KAAJ,CAAU,KAAKkT,KAAf,CAAf;AACA,QAAIrV,CAAC,GAAG,CAAR;;AAEA,WAAS+E,IAAI,GAAGF,QAAQ,CAACG,IAAT,EAAR,EAA0BD,IAAI,CAACE,IAAL,KAAc,IAAhD,EAAuD;AACrDkB,MAAAA,QAAQ,GAAGpB,IAAI,CAAC9D,KAAhB;AACAoL,MAAAA,MAAM,CAACrM,CAAC,EAAF,CAAN,GAAc2I,QAAQ,CAACxC,QAAQ,CAACjD,GAAV,EAAeiD,QAAQ,CAACjE,UAAxB,CAAtB;AACD;;AAED,WAAOmK,MAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;SACEiJ,WAAA,kBAAS3M,QAAT,EAAmB;AACjB,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAI/F,0BAAJ,CACJ,uCADI,CAAN;;AAIF,QAAMiC,QAAQ,GAAG,KAAKlE,MAAL,CAAYmE,MAAZ,EAAjB;;AAEA,QAAIC,IAAJ,EAAUoB,QAAV;;AAEA,WAASpB,IAAI,GAAGF,QAAQ,CAACG,IAAT,EAAR,EAA0BD,IAAI,CAACE,IAAL,KAAc,IAAhD,EAAuD;AACrDkB,MAAAA,QAAQ,GAAGpB,IAAI,CAAC9D,KAAhB;AAEA,UAAI0H,QAAQ,CAACxC,QAAQ,CAACjD,GAAV,EAAeiD,QAAQ,CAACjE,UAAxB,CAAZ,EAAiD,OAAO,IAAP;AAClD;;AAED,WAAO,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;SACEqT,YAAA,mBAAU5M,QAAV,EAAoB;AAClB,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAI/F,0BAAJ,CACJ,wCADI,CAAN;;AAIF,QAAMiC,QAAQ,GAAG,KAAKlE,MAAL,CAAYmE,MAAZ,EAAjB;;AAEA,QAAIC,IAAJ,EAAUoB,QAAV;;AAEA,WAASpB,IAAI,GAAGF,QAAQ,CAACG,IAAT,EAAR,EAA0BD,IAAI,CAACE,IAAL,KAAc,IAAhD,EAAuD;AACrDkB,MAAAA,QAAQ,GAAGpB,IAAI,CAAC9D,KAAhB;AAEA,UAAI,CAAC0H,QAAQ,CAACxC,QAAQ,CAACjD,GAAV,EAAeiD,QAAQ,CAACjE,UAAxB,CAAb,EAAkD,OAAO,KAAP;AACnD;;AAED,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;SACEsT,cAAA,qBAAY7M,QAAZ,EAAsB;AACpB,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAI/F,0BAAJ,CACJ,0CADI,CAAN;;AAIF,QAAMiC,QAAQ,GAAG,KAAKlE,MAAL,CAAYmE,MAAZ,EAAjB;;AAEA,QAAIC,IAAJ,EAAUoB,QAAV;AAEA,QAAMkG,MAAM,GAAG,EAAf;;AAEA,WAAStH,IAAI,GAAGF,QAAQ,CAACG,IAAT,EAAR,EAA0BD,IAAI,CAACE,IAAL,KAAc,IAAhD,EAAuD;AACrDkB,MAAAA,QAAQ,GAAGpB,IAAI,CAAC9D,KAAhB;AAEA,UAAI0H,QAAQ,CAACxC,QAAQ,CAACjD,GAAV,EAAeiD,QAAQ,CAACjE,UAAxB,CAAZ,EACEmK,MAAM,CAAC7D,IAAP,CAAYrC,QAAQ,CAACjD,GAArB;AACH;;AAED,WAAOmJ,MAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;SACEoJ,cAAA,qBAAY9M,QAAZ,EAAsBqE,YAAtB,EAAoC;AAClC,QAAI,OAAOrE,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAI/F,0BAAJ,CACJ,0CADI,CAAN;AAIF,QAAI7C,SAAS,CAACG,MAAV,GAAmB,CAAvB,EACE,MAAM,IAAI0C,0BAAJ,CACJ,mNADI,CAAN;AAIF,QAAIqK,WAAW,GAAGD,YAAlB;;AAEA,QAAMnI,QAAQ,GAAG,KAAKlE,MAAL,CAAYmE,MAAZ,EAAjB;;AAEA,QAAIC,IAAJ,EAAUoB,QAAV;;AAEA,WAASpB,IAAI,GAAGF,QAAQ,CAACG,IAAT,EAAR,EAA0BD,IAAI,CAACE,IAAL,KAAc,IAAhD,EAAuD;AACrDkB,MAAAA,QAAQ,GAAGpB,IAAI,CAAC9D,KAAhB;AACAgM,MAAAA,WAAW,GAAGtE,QAAQ,CAACsE,WAAD,EAAc9G,QAAQ,CAACjD,GAAvB,EAA4BiD,QAAQ,CAACjE,UAArC,CAAtB;AACD;;AAED,WAAO+K,WAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;SACEyI,cAAA,uBAAc;AACZ,QAAM7Q,QAAQ,GAAG,KAAKlE,MAAL,CAAYmE,MAAZ,EAAjB;;AAEA,WAAO,IAAIsE,4BAAJ,CAAa,YAAM;AACxB,UAAMrE,IAAI,GAAGF,QAAQ,CAACG,IAAT,EAAb;AAEA,UAAID,IAAI,CAACE,IAAT,EAAe,OAAOF,IAAP;AAEf,UAAMK,IAAI,GAAGL,IAAI,CAAC9D,KAAlB;AAEA,aAAO;AACLA,QAAAA,KAAK,EAAE;AAACoE,UAAAA,IAAI,EAAED,IAAI,CAAClC,GAAZ;AAAiBhB,UAAAA,UAAU,EAAEkD,IAAI,CAAClD;AAAlC,SADF;AAEL+C,QAAAA,IAAI,EAAE;AAFD,OAAP;AAID,KAXM,CAAP;AAYD;AAED;AACF;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACE0Q,aAAA,oBAAWtQ,IAAX,EAAiB;AACfA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMD,IAAI,GAAG,KAAKzE,MAAL,CAAYC,GAAZ,CAAgByE,IAAhB,CAAb;;AAEA,QAAI,CAACD,IAAL,EACE,MAAM,IAAIrC,kBAAJ,kDACqCsC,IADrC,2BAAN;AAIF,WAAOoK,aAAa,CAACpK,IAAD,EAAOD,IAAP,CAApB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;SACEwQ,aAAA,oBAAW/U,IAAX,EAAiB;AACfA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMuE,IAAI,GAAG,KAAKkB,MAAL,CAAY1F,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAACuE,IAAL,EACE,MAAM,IAAIrC,kBAAJ,kDACqClC,IADrC,2BAAN;AAIF,WAAO8O,aAAa,CAAC9O,IAAD,EAAOuE,IAAP,CAApB;AACD;AAED;AACF;AACA;AACA;AACA;;;qBACE,mBAAS;AACP,QAAM6P,KAAK,GAAG,IAAI9S,KAAJ,CAAU,KAAKxB,MAAL,CAAY+D,IAAtB,CAAd;AAEA,QAAI1E,CAAC,GAAG,CAAR;;AAEA,SAAKW,MAAL,CAAYwE,OAAZ,CAAoB,UAACC,IAAD,EAAOlC,GAAP,EAAe;AACjC+R,MAAAA,KAAK,CAACjV,CAAC,EAAF,CAAL,GAAayP,aAAa,CAACvM,GAAD,EAAMkC,IAAN,CAA1B;AACD,KAFD;;AAIA,QAAMG,KAAK,GAAG,IAAIpD,KAAJ,CAAU,KAAKmE,MAAL,CAAY5B,IAAtB,CAAd;AAEA1E,IAAAA,CAAC,GAAG,CAAJ;;AAEA,SAAKsG,MAAL,CAAYnB,OAAZ,CAAoB,UAACC,IAAD,EAAOlC,GAAP,EAAe;AACjCqC,MAAAA,KAAK,CAACvF,CAAC,EAAF,CAAL,GAAa2P,aAAa,CAACzM,GAAD,EAAMkC,IAAN,CAA1B;AACD,KAFD;;AAIA,WAAO;AACLlD,MAAAA,UAAU,EAAE,KAAKiS,aAAL,EADP;AAELc,MAAAA,KAAK,EAALA,KAFK;AAGL1P,MAAAA,KAAK,EAALA,KAHK;AAILkM,MAAAA,OAAO,EAAE;AACPhR,QAAAA,IAAI,EAAE,KAAKA,IADJ;AAEPuD,QAAAA,KAAK,EAAE,KAAKA,KAFL;AAGPqM,QAAAA,cAAc,EAAE,KAAKA;AAHd;AAJJ,KAAP;AAUD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;SACEwF,aAAA,oBAAWzQ,IAAX,EAAgC;AAAA,QAAfsI,KAAe,uEAAP,KAAO;AAC9B;AACA,QAAMoI,KAAK,GAAGlG,sBAAsB,CAACxK,IAAD,CAApC;;AAEA,QAAI0Q,KAAJ,EAAW;AACT,UAAIA,KAAK,KAAK,YAAd,EACE,MAAM,IAAIlT,0BAAJ,CACJ,uHADI,CAAN;AAGF,UAAIkT,KAAK,KAAK,QAAd,EACE,MAAM,IAAIlT,0BAAJ,CACJ,oCADI,CAAN;AAGF,UAAIkT,KAAK,KAAK,oBAAd,EACE,MAAM,IAAIlT,0BAAJ,CACJ,6FADI,CAAN;AAGH,KAjB6B;;;AAoB9B,QAAOM,GAAP,GAA+BkC,IAA/B,CAAOlC,GAAP;AAAA,2BAA+BkC,IAA/B,CAAYlD,UAAZ;AAAA,QAAYA,UAAZ,iCAAyB,EAAzB;AAEA,QAAIwL,KAAJ,EAAW,KAAKmG,SAAL,CAAe3Q,GAAf,EAAoBhB,UAApB,EAAX,KACK,KAAKoO,OAAL,CAAapN,GAAb,EAAkBhB,UAAlB;AAEL,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;SACE6T,aAAA,oBAAW3Q,IAAX,EAAgC;AAAA,QAAfsI,KAAe,uEAAP,KAAO;AAC9B;AACA,QAAMoI,KAAK,GAAGjG,sBAAsB,CAACzK,IAAD,CAApC;;AAEA,QAAI0Q,KAAJ,EAAW;AACT,UAAIA,KAAK,KAAK,YAAd,EACE,MAAM,IAAIlT,0BAAJ,CACJ,qIADI,CAAN;AAGF,UAAIkT,KAAK,KAAK,WAAd,EACE,MAAM,IAAIlT,0BAAJ,CACJ,kCADI,CAAN;AAGF,UAAIkT,KAAK,KAAK,WAAd,EACE,MAAM,IAAIlT,0BAAJ,CACJ,mCADI,CAAN;AAGF,UAAIkT,KAAK,KAAK,oBAAd,EACE,MAAM,IAAIlT,0BAAJ,CACJ,6FADI,CAAN;AAGF,UAAIkT,KAAK,KAAK,oBAAd,EACE,MAAM,IAAIlT,0BAAJ,CACJ,gFADI,CAAN;AAGH,KAzB6B;;;AA4B9B,QAAOpC,MAAP,GAA8D4E,IAA9D,CAAO5E,MAAP;AAAA,QAAeV,MAAf,GAA8DsF,IAA9D,CAAetF,MAAf;AAAA,4BAA8DsF,IAA9D,CAAuBlD,UAAvB;AAAA,QAAuBA,UAAvB,kCAAoC,EAApC;AAAA,2BAA8DkD,IAA9D,CAAwCrE,UAAxC;AAAA,QAAwCA,UAAxC,iCAAqD,KAArD;AAEA,QAAI8E,MAAJ;;AAEA,QAAI,SAAST,IAAb,EAAmB;AACjBS,MAAAA,MAAM,GAAG6H,KAAK,GACV3M,UAAU,GACR,KAAKiV,0BADG,GAER,KAAKC,wBAHG,GAIVlV,UAAU,GACV,KAAKG,wBADK,GAEV,KAAKgV,sBANT;AAQArQ,MAAAA,MAAM,CAACsG,IAAP,CAAY,IAAZ,EAAkB/G,IAAI,CAAClC,GAAvB,EAA4B1C,MAA5B,EAAoCV,MAApC,EAA4CoC,UAA5C;AACD,KAVD,MAUO;AACL2D,MAAAA,MAAM,GAAG6H,KAAK,GACV3M,UAAU,GACR,KAAKoV,mBADG,GAER,KAAKC,iBAHG,GAIVrV,UAAU,GACV,KAAKsV,iBADK,GAEV,KAAKC,eANT;AAQAzQ,MAAAA,MAAM,CAACsG,IAAP,CAAY,IAAZ,EAAkB3L,MAAlB,EAA0BV,MAA1B,EAAkCoC,UAAlC;AACD;;AAED,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;qBACE,iBAAOkD,IAAP,EAA4B;AAAA,QAAfsI,KAAe,uEAAP,KAAO;;AAC1B;AACA,QAAI1M,OAAO,CAACoE,IAAD,CAAX,EAAmB;AACjB,qBAAYA,IAAI,UAAJ,EAAZ,EAA2BsI,KAA3B;AACA,aAAO,IAAP;AACD,KALyB;;;AAQ1B,QAAI,CAACtM,aAAa,CAACgE,IAAD,CAAlB,EACE,MAAM,IAAIxC,0BAAJ,CACJ,mGADI,CAAN;;AAIF,QAAIwC,IAAI,CAAClD,UAAT,EAAqB;AACnB,UAAI,CAACd,aAAa,CAACgE,IAAI,CAAClD,UAAN,CAAlB,EACE,MAAM,IAAIU,0BAAJ,CACJ,6DADI,CAAN;AAIF,UAAI8K,KAAJ,EAAW,KAAK+G,eAAL,CAAqBrP,IAAI,CAAClD,UAA1B,EAAX,KACK,KAAKsS,iBAAL,CAAuBpP,IAAI,CAAClD,UAA5B;AACN;;AAED,QAAIlC,CAAJ,EAAOC,CAAP,EAAUqK,IAAV;;AAEA,QAAIlF,IAAI,CAAC6P,KAAT,EAAgB;AACd3K,MAAAA,IAAI,GAAGlF,IAAI,CAAC6P,KAAZ;AAEA,UAAI,CAAC9S,KAAK,CAACC,OAAN,CAAckI,IAAd,CAAL,EACE,MAAM,IAAI1H,0BAAJ,CACJ,kDADI,CAAN;;AAIF,WAAK5C,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGqK,IAAI,CAACpK,MAArB,EAA6BF,CAAC,GAAGC,CAAjC,EAAoCD,CAAC,EAArC;AAAyC,aAAK6V,UAAL,CAAgBvL,IAAI,CAACtK,CAAD,CAApB,EAAyB0N,KAAzB;AAAzC;AACD;;AAED,QAAItI,IAAI,CAACG,KAAT,EAAgB;AACd+E,MAAAA,IAAI,GAAGlF,IAAI,CAACG,KAAZ;AAEA,UAAI,CAACpD,KAAK,CAACC,OAAN,CAAckI,IAAd,CAAL,EACE,MAAM,IAAI1H,0BAAJ,CACJ,kDADI,CAAN;;AAIF,WAAK5C,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGqK,IAAI,CAACpK,MAArB,EAA6BF,CAAC,GAAGC,CAAjC,EAAoCD,CAAC,EAArC;AAAyC,aAAK+V,UAAL,CAAgBzL,IAAI,CAACtK,CAAD,CAApB,EAAyB0N,KAAzB;AAAzC;AACD;;AAED,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;;;SACE6I,WAAA,kBAAS9E,OAAT,EAAkB;AAChB,QAAMlR,KAAK,GAAG,IAAIiH,KAAJ,CAAUpH,MAAM,CAAC,EAAD,EAAK,KAAK4R,QAAV,EAAoBP,OAApB,CAAhB,CAAd;AACAlR,IAAAA,KAAK,CAACiU,iBAAN,CAAwBpU,MAAM,CAAC,EAAD,EAAK,KAAK+T,aAAL,EAAL,CAA9B;AACA,WAAO5T,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;SACEiW,YAAA,mBAAU/E,OAAV,EAAmB;AACjB,QAAMlR,KAAK,GAAG,KAAKgW,QAAL,CAAc9E,OAAd,CAAd;;AAEA,SAAK9Q,MAAL,CAAYwE,OAAZ,CAAoB,UAACgB,QAAD,EAAWjD,GAAX,EAAmB;AACrC,UAAMhB,UAAU,GAAG9B,MAAM,CAAC,EAAD,EAAK+F,QAAQ,CAACjE,UAAd,CAAzB,CADqC;;AAIrCiE,MAAAA,QAAQ,GAAG,IAAI5F,KAAK,CAACgQ,aAAV,CAAwBrN,GAAxB,EAA6BhB,UAA7B,CAAX;;AACA3B,MAAAA,KAAK,CAACI,MAAN,CAAa8D,GAAb,CAAiBvB,GAAjB,EAAsBiD,QAAtB;AACD,KAND;;AAQA,WAAO5F,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;SACEkW,OAAA,gBAAO;AACL,QAAMlW,KAAK,GAAG,KAAKiW,SAAL,EAAd;;AAEA,QAAM3R,QAAQ,GAAG,KAAKyB,MAAL,CAAYxB,MAAZ,EAAjB;;AAEA,QAAIC,IAAJ,EAAUjB,QAAV;;AAEA,WAASiB,IAAI,GAAGF,QAAQ,CAACG,IAAT,EAAR,EAA0BD,IAAI,CAACE,IAAL,KAAc,IAAhD,EAAuD;AACrDnB,MAAAA,QAAQ,GAAGiB,IAAI,CAAC9D,KAAhB,CADqD;;AAIrDwP,MAAAA,OAAO,CACLlQ,KADK,EAEL,MAFK,EAGL,KAHK,EAILuD,QAAQ,CAAC/C,UAJJ,EAKL+C,QAAQ,CAACZ,GALJ,EAMLY,QAAQ,CAACtD,MAAT,CAAgB0C,GANX,EAOLY,QAAQ,CAAChE,MAAT,CAAgBoD,GAPX,EAQL9C,MAAM,CAAC,EAAD,EAAK0D,QAAQ,CAAC5B,UAAd,CARD,CAAP;AAUD;;AAED,WAAO3B,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;SACEmD,iBAAA,0BAAiB;AACf,QAAI,KAAKjD,IAAL,KAAc,OAAlB,EAA2B,OAAO,IAAP,CADZ;AAIf;AACA;AACA;AACA;;AACA,SAAKE,MAAL,CAAYwE,OAAZ,CAAoB,UAAAC,IAAI;AAAA,aAAIA,IAAI,CAAC1B,cAAL,EAAJ;AAAA,KAAxB,EARe;;;AAWf,SAAKsO,QAAL,CAAcvR,IAAd,GAAqB,OAArB;AACAqB,IAAAA,gBAAgB,CAAC,IAAD,EAAO,MAAP,EAAe,KAAKkQ,QAAL,CAAcvR,IAA7B,CAAhB;AACAe,IAAAA,eAAe,CAAC,IAAD,EAAO,eAAP,EAAwByB,aAAxB,CAAf;AAEA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;SACEyT,iBAAA,0BAAiB;AACf,QAAI,KAAK1S,KAAT,EAAgB,OAAO,IAAP,CADD;;AAIf,SAAKgO,QAAL,CAAchO,KAAd,GAAsB,IAAtB;AACAlC,IAAAA,gBAAgB,CAAC,IAAD,EAAO,OAAP,EAAgB,IAAhB,CAAhB,CALe;;AAQfoD,IAAAA,4BAA4B,CAAC,IAAD,CAA5B;AAEA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;;;SACEyR,SAAA,kBAAS;AACP,WAAO,gBAAP;AACD;AAED;AACF;AACA;;;SACEC,WAAA,oBAAW;AACT,WAAO,gBAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;SACEC,UAAA,mBAAU;AAAA;;AACR,QAAM5B,KAAK,GAAG,EAAd;;AACA,SAAKtU,MAAL,CAAYwE,OAAZ,CAAoB,UAACC,IAAD,EAAOlC,GAAP,EAAe;AACjC+R,MAAAA,KAAK,CAAC/R,GAAD,CAAL,GAAakC,IAAI,CAAClD,UAAlB;AACD,KAFD;;AAIA,QAAMqD,KAAK,GAAG,EAAd;AAAA,QACEuR,UAAU,GAAG,EADf;;AAGA,SAAKxQ,MAAL,CAAYnB,OAAZ,CAAoB,UAACC,IAAD,EAAOlC,GAAP,EAAe;AACjC,UAAMmF,SAAS,GAAGjD,IAAI,CAACrE,UAAL,GAAkB,IAAlB,GAAyB,IAA3C;AAEA,UAAIgW,KAAK,GAAG,EAAZ;AAEA,UAAIvW,MAAM,GAAG4E,IAAI,CAAC5E,MAAL,CAAY0C,GAAzB;AACA,UAAIpD,MAAM,GAAGsF,IAAI,CAACtF,MAAL,CAAYoD,GAAzB;AACA,UAAI8T,GAAJ;;AAEA,UAAI5R,IAAI,CAACrE,UAAL,IAAmBP,MAAM,GAAGV,MAAhC,EAAwC;AACtCkX,QAAAA,GAAG,GAAGxW,MAAN;AACAA,QAAAA,MAAM,GAAGV,MAAT;AACAA,QAAAA,MAAM,GAAGkX,GAAT;AACD;;AAED,UAAMC,IAAI,cAAOzW,MAAP,cAAiB6H,SAAjB,cAA8BvI,MAA9B,MAAV;;AAEA,UAAI,CAACoD,GAAG,CAACgU,UAAJ,CAAe,OAAf,CAAL,EAA8B;AAC5BH,QAAAA,KAAK,eAAQ7T,GAAR,QAAL;AACD,OAFD,MAEO,IAAI,MAAI,CAACc,KAAT,EAAgB;AACrB,YAAI,OAAO8S,UAAU,CAACG,IAAD,CAAjB,KAA4B,WAAhC,EAA6C;AAC3CH,UAAAA,UAAU,CAACG,IAAD,CAAV,GAAmB,CAAnB;AACD,SAFD,MAEO;AACLH,UAAAA,UAAU,CAACG,IAAD,CAAV;AACD;;AAEDF,QAAAA,KAAK,cAAOD,UAAU,CAACG,IAAD,CAAjB,OAAL;AACD;;AAEDF,MAAAA,KAAK,IAAIE,IAAT;AAEA1R,MAAAA,KAAK,CAACwR,KAAD,CAAL,GAAe3R,IAAI,CAAClD,UAApB;AACD,KAhCD;;AAkCA,QAAMiV,KAAK,GAAG,EAAd;;AAEA,SAAK,IAAMhX,CAAX,IAAgB,IAAhB,EAAsB;AACpB,UACE,KAAKwG,cAAL,CAAoBxG,CAApB,KACA,CAAC6P,aAAa,CAACpE,GAAd,CAAkBzL,CAAlB,CADD,IAEA,OAAO,KAAKA,CAAL,CAAP,KAAmB,UAFnB,IAGA,QAAOA,CAAP,MAAa,QAJf,EAMEgX,KAAK,CAAChX,CAAD,CAAL,GAAW,KAAKA,CAAL,CAAX;AACH;;AAEDgX,IAAAA,KAAK,CAACjV,UAAN,GAAmB,KAAKgS,WAAxB;AACAiD,IAAAA,KAAK,CAAClC,KAAN,GAAcA,KAAd;AACAkC,IAAAA,KAAK,CAAC5R,KAAN,GAAcA,KAAd;AAEA/D,IAAAA,eAAe,CAAC2V,KAAD,EAAQ,aAAR,EAAuB,KAAK9V,WAA5B,CAAf;AAEA,WAAO8V,KAAP;AACD;;;EAprEgCC;AAksEnC,IAAI,OAAOC,MAAP,KAAkB,WAAtB,EACE7P,KAAK,CAAC1E,SAAN,CAAgBuU,MAAM,OAAN,CAAW,4BAAX,CAAhB,IACE7P,KAAK,CAAC1E,SAAN,CAAgB+T,OADlB;AAGF;AACA;AACA;;AACA5G,gBAAgB,CAAC9K,OAAjB,CAAyB,UAAAU,MAAM,EAAI;AACjC,GAAC,KAAD,EAAQ,OAAR,EAAiB,QAAjB,EAA2BV,OAA3B,CAAmC,UAAA+K,IAAI,EAAI;AACzC,QAAMzO,IAAI,GAAGoE,MAAM,CAACpE,IAAP,CAAYyO,IAAZ,CAAb;AACA,QAAMpF,EAAE,GAAGoF,IAAI,KAAK,KAAT,GAAiBO,OAAjB,GAA2BQ,SAAtC;;AAEA,QAAIpL,MAAM,CAACsK,WAAX,EAAwB;AACtB3I,MAAAA,KAAK,CAAC1E,SAAN,CAAgBrB,IAAhB,IAAwB,UAAUjB,MAAV,EAAkBV,MAAlB,EAA0BoC,UAA1B,EAAsC;AAC5D,eAAO4I,EAAE,CACP,IADO,EAEPrJ,IAFO,EAGP,IAHO,EAIP,CAACoE,MAAM,CAACpF,IAAP,IAAe,KAAKA,IAArB,MAA+B,YAJxB,EAKP,IALO,EAMPD,MANO,EAOPV,MAPO,EAQPoC,UARO,EASPgO,IAAI,KAAK,QATF,CAAT;AAWD,OAZD;AAaD,KAdD,MAcO;AACL1I,MAAAA,KAAK,CAAC1E,SAAN,CAAgBrB,IAAhB,IAAwB,UAAUZ,IAAV,EAAgBL,MAAhB,EAAwBV,MAAxB,EAAgCoC,UAAhC,EAA4C;AAClE,eAAO4I,EAAE,CACP,IADO,EAEPrJ,IAFO,EAGP,KAHO,EAIP,CAACoE,MAAM,CAACpF,IAAP,IAAe,KAAKA,IAArB,MAA+B,YAJxB,EAKPI,IALO,EAMPL,MANO,EAOPV,MAPO,EAQPoC,UARO,EASPgO,IAAI,KAAK,QATF,CAAT;AAWD,OAZD;AAaD;AACF,GAjCD;AAkCD,CAnCD;AAqCA;AACA;AACA;;AACA3I,2BAA2B,CAACC,KAAD,CAA3B;AACAW,2BAA2B,CAACX,KAAD,CAA3B;AAEA;AACA;AACA;;AACAgG,0BAA0B,CAAChG,KAAD,CAA1B;AAEA;AACA;AACA;;AACAyH,8BAA8B,CAACzH,KAAD,CAA9B;;ACtyFA;AACA;AACA;;IACM8P;;;AACJ,yBAAY7F,OAAZ,EAAqB;AACnB,QAAM8F,YAAY,GAAGnX,MAAM,CAAC;AAACK,MAAAA,IAAI,EAAE;AAAP,KAAD,EAAqBgR,OAArB,CAA3B;AAEA,QAAI,WAAW8F,YAAX,IAA2BA,YAAY,CAACvT,KAAb,KAAuB,KAAtD,EACE,MAAM,IAAIpB,0BAAJ,CACJ,8FADI,CAAN;AAIF,QAAI2U,YAAY,CAAC9W,IAAb,KAAsB,UAA1B,EACE,MAAM,IAAImC,0BAAJ,CACJ,uCACE2U,YAAY,CAAC9W,IADf,GAEE,0BAHE,CAAN;AATiB,WAenB,kBAAM8W,YAAN,CAfmB;AAgBpB;;;EAjByB/P;;IAmBtBgQ;;;AACJ,2BAAY/F,OAAZ,EAAqB;AACnB,QAAM8F,YAAY,GAAGnX,MAAM,CAAC;AAACK,MAAAA,IAAI,EAAE;AAAP,KAAD,EAAuBgR,OAAvB,CAA3B;AAEA,QAAI,WAAW8F,YAAX,IAA2BA,YAAY,CAACvT,KAAb,KAAuB,KAAtD,EACE,MAAM,IAAIpB,0BAAJ,CACJ,gGADI,CAAN;AAIF,QAAI2U,YAAY,CAAC9W,IAAb,KAAsB,YAA1B,EACE,MAAM,IAAImC,0BAAJ,CACJ,yCACE2U,YAAY,CAAC9W,IADf,GAEE,0BAHE,CAAN;AATiB,WAenB,mBAAM8W,YAAN,CAfmB;AAgBpB;;;EAjB2B/P;;IAmBxBiQ;;;AACJ,sBAAYhG,OAAZ,EAAqB;AACnB,QAAM8F,YAAY,GAAGnX,MAAM,CAAC;AAAC4D,MAAAA,KAAK,EAAE;AAAR,KAAD,EAAgByN,OAAhB,CAA3B;AAEA,QAAI,WAAW8F,YAAX,IAA2BA,YAAY,CAACvT,KAAb,KAAuB,IAAtD,EACE,MAAM,IAAIpB,0BAAJ,CACJ,4FADI,CAAN;AAJiB,WAQnB,mBAAM2U,YAAN,CARmB;AASpB;;;EAVsB/P;;IAYnBkQ;;;AACJ,8BAAYjG,OAAZ,EAAqB;AACnB,QAAM8F,YAAY,GAAGnX,MAAM,CAAC;AAACK,MAAAA,IAAI,EAAE,UAAP;AAAmBuD,MAAAA,KAAK,EAAE;AAA1B,KAAD,EAAkCyN,OAAlC,CAA3B;AAEA,QAAI,WAAW8F,YAAX,IAA2BA,YAAY,CAACvT,KAAb,KAAuB,IAAtD,EACE,MAAM,IAAIpB,0BAAJ,CACJ,oGADI,CAAN;AAIF,QAAI2U,YAAY,CAAC9W,IAAb,KAAsB,UAA1B,EACE,MAAM,IAAImC,0BAAJ,CACJ,4CACE2U,YAAY,CAAC9W,IADf,GAEE,0BAHE,CAAN;AATiB,WAenB,mBAAM8W,YAAN,CAfmB;AAgBpB;;;EAjB8B/P;;IAmB3BmQ;;;AACJ,gCAAYlG,OAAZ,EAAqB;AACnB,QAAM8F,YAAY,GAAGnX,MAAM,CAAC;AAACK,MAAAA,IAAI,EAAE,YAAP;AAAqBuD,MAAAA,KAAK,EAAE;AAA5B,KAAD,EAAoCyN,OAApC,CAA3B;AAEA,QAAI,WAAW8F,YAAX,IAA2BA,YAAY,CAACvT,KAAb,KAAuB,IAAtD,EACE,MAAM,IAAIpB,0BAAJ,CACJ,sGADI,CAAN;AAIF,QAAI2U,YAAY,CAAC9W,IAAb,KAAsB,YAA1B,EACE,MAAM,IAAImC,0BAAJ,CACJ,8CACE2U,YAAY,CAAC9W,IADf,GAEE,0BAHE,CAAN;AATiB,WAenB,mBAAM8W,YAAN,CAfmB;AAgBpB;;;EAjBgC/P;AAoBnC;AACA;AACA;;;AACA,SAASoQ,sBAAT,CAAgCpR,KAAhC,EAAuC;AACrC;AACF;AACA;AACA;AACA;AACA;AACA;AACEA,EAAAA,KAAK,CAAC0D,IAAN,GAAa,UAAU9E,IAAV,EAAgBqM,OAAhB,EAAyB;AACpC;AACA,QAAM8F,YAAY,GAAGnX,MAAM,CAAC,EAAD,EAAKgF,IAAI,CAACqM,OAAV,EAAmBA,OAAnB,CAA3B;AAEA,QAAMoG,QAAQ,GAAG,IAAIrR,KAAJ,CAAU+Q,YAAV,CAAjB;AACAM,IAAAA,QAAQ,UAAR,CAAgBzS,IAAhB;AAEA,WAAOyS,QAAP;AACD,GARD;AASD;;AAEDD,sBAAsB,CAACpQ,KAAD,CAAtB;AACAoQ,sBAAsB,CAACN,aAAD,CAAtB;AACAM,sBAAsB,CAACJ,eAAD,CAAtB;AACAI,sBAAsB,CAACH,UAAD,CAAtB;AACAG,sBAAsB,CAACF,kBAAD,CAAtB;AACAE,sBAAsB,CAACD,oBAAD,CAAtB;AAEAnQ,KAAK,CAACA,KAAN,GAAcA,KAAd;AACAA,KAAK,CAAC8P,aAAN,GAAsBA,aAAtB;AACA9P,KAAK,CAACgQ,eAAN,GAAwBA,eAAxB;AACAhQ,KAAK,CAACiQ,UAAN,GAAmBA,UAAnB;AACAjQ,KAAK,CAACkQ,kBAAN,GAA2BA,kBAA3B;AACAlQ,KAAK,CAACmQ,oBAAN,GAA6BA,oBAA7B;AAEAnQ,KAAK,CAAC5E,0BAAN,GAAmCA,0BAAnC;AACA4E,KAAK,CAACzE,kBAAN,GAA2BA,kBAA3B;AACAyE,KAAK,CAACxE,eAAN,GAAwBA,eAAxB;;AClJA;AACA;AACA;AACA;AACA;AACA;;;;"}