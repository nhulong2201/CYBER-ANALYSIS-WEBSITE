{"version":3,"file":"graphology.umd.js","sources":["../src/utils.js","../../../node_modules/events/events.js","../../../node_modules/obliterator/iterator.js","../../../node_modules/obliterator/support.js","../../../node_modules/obliterator/iter.js","../../../node_modules/obliterator/take.js","../src/errors.js","../src/data.js","../src/indices.js","../src/attributes/nodes.js","../src/attributes/edges.js","../../../node_modules/obliterator/chain.js","../src/iteration/edges.js","../src/iteration/neighbors.js","../src/iteration/adjacency.js","../src/serialization.js","../src/graph.js","../src/classes.js","../src/endpoint.cjs.js"],"sourcesContent":["/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a Graph implementation instance.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function'\n  );\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' && value !== null && value.constructor === Object\n  );\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n  if (typeof next !== 'function')\n    throw new Error('obliterator/iterator: expecting a function!');\n\n  this.next = next;\n}\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function () {\n  var args = arguments,\n    l = args.length,\n    i = 0;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function () {\n  var iterator = new Iterator(function () {\n    return {done: true};\n  });\n\n  return iterator;\n};\n\n/**\n * Returning an iterator over the given indexed sequence.\n *\n * @param  {string|Array} sequence - Target sequence.\n * @return {Iterator}\n */\nIterator.fromSequence = function (sequence) {\n  var i = 0,\n    l = sequence.length;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: sequence[i++]};\n  });\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function (value) {\n  if (value instanceof Iterator) return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n","exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== 'undefined';\nexports.SYMBOL_SUPPORT = typeof Symbol !== 'undefined';\n","/**\n * Obliterator Iter Function\n * ==========================\n *\n * Function coercing values to an iterator. It can be quite useful when needing\n * to handle iterables and iterators the same way.\n */\nvar Iterator = require('./iterator.js');\nvar support = require('./support.js');\n\nvar ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;\nvar SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;\n\nfunction iterOrNull(target) {\n  // Indexed sequence\n  if (\n    typeof target === 'string' ||\n    Array.isArray(target) ||\n    (ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(target))\n  )\n    return Iterator.fromSequence(target);\n\n  // Invalid value\n  if (typeof target !== 'object' || target === null) return null;\n\n  // Iterable\n  if (SYMBOL_SUPPORT && typeof target[Symbol.iterator] === 'function')\n    return target[Symbol.iterator]();\n\n  // Iterator duck-typing\n  if (typeof target.next === 'function') return target;\n\n  // Invalid object\n  return null;\n}\n\nmodule.exports = function iter(target) {\n  var iterator = iterOrNull(target);\n\n  if (!iterator)\n    throw new Error(\n      'obliterator: target is not iterable nor a valid iterator.'\n    );\n\n  return iterator;\n};\n","/* eslint no-constant-condition: 0 */\n/**\n * Obliterator Take Function\n * ==========================\n *\n * Function taking n or every value of the given iterator and returns them\n * into an array.\n */\nvar iter = require('./iter.js');\n\n/**\n * Take.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {number}   [n]      - Optional number of items to take.\n * @return {array}\n */\nmodule.exports = function take(iterable, n) {\n  var l = arguments.length > 1 ? n : Infinity,\n    array = l !== Infinity ? new Array(l) : [],\n    step,\n    i = 0;\n\n  var iterator = iter(iterable);\n\n  while (true) {\n    if (i === l) return array;\n\n    step = iterator.next();\n\n    if (step.done) {\n      if (i !== n) array.length = i;\n\n      return array;\n    }\n\n    array[i++] = step.value;\n  }\n};\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.directedSelfLoops = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\nDirectedNodeData.prototype.upgradeToMixed = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\nUndirectedNodeData.prototype.upgradeToMixed = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n","/**\n * Graphology Indexes Functions\n * =============================\n *\n * Bunch of functions used to compute or clear indexes.\n */\n\n/**\n * Function updating the 'structure' index with the given edge's data.\n * Note that in the case of the multi graph, related edges are stored in a\n * set that is the same for A -> B & B <- A.\n *\n * @param {Graph}    graph      - Target Graph instance.\n * @param {EdgeData} edgeData   - Added edge's data.\n * @param {NodeData} sourceData - Source node's data.\n * @param {NodeData} targetData - Target node's data.\n */\nexport function updateStructureIndex(\n  graph,\n  undirected,\n  edgeData,\n  source,\n  target,\n  sourceData,\n  targetData\n) {\n  const multi = graph.multi;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (undirected) outKey = inKey = 'undirected';\n\n  let adj, container;\n\n  if (multi) {\n    // Handling source\n    adj = sourceData[outKey];\n    container = adj[target];\n\n    if (typeof container === 'undefined') {\n      container = new Set();\n      adj[target] = container;\n    }\n\n    container.add(edgeData);\n\n    // If selfLoop, we break here\n    if (source === target && undirected) return;\n\n    // Handling target (we won't add the edge because it was already taken\n    // care of with source above)\n    adj = targetData[inKey];\n    if (typeof adj[source] === 'undefined') adj[source] = container;\n  } else {\n    // Handling source\n    sourceData[outKey][target] = edgeData;\n\n    // If selfLoop, we break here\n    if (source === target && undirected) return;\n\n    // Handling target\n    targetData[inKey][source] = edgeData;\n  }\n}\n\n/**\n * Function clearing the 'structure' index data related to the given edge.\n *\n * @param {Graph}    graph    - Target Graph instance.\n * @param {EdgeData} edgeData - Dropped edge's data.\n */\nexport function clearEdgeFromStructureIndex(graph, undirected, edgeData) {\n  const multi = graph.multi;\n\n  const {source: sourceData, target: targetData} = edgeData;\n\n  const source = sourceData.key,\n    target = targetData.key;\n\n  // NOTE: since the edge set is the same for source & target, we can only\n  // affect source\n  const outKey = undirected ? 'undirected' : 'out',\n    sourceIndex = sourceData[outKey];\n\n  const inKey = undirected ? 'undirected' : 'in';\n\n  if (target in sourceIndex) {\n    if (multi) {\n      const set = sourceIndex[target];\n\n      if (set.size === 1) {\n        delete sourceIndex[target];\n        delete targetData[inKey][source];\n      } else {\n        set.delete(edgeData);\n      }\n    } else delete sourceIndex[target];\n  }\n\n  if (multi) return;\n\n  const targetIndex = targetData[inKey];\n\n  delete targetIndex[source];\n}\n\n/**\n * Function clearing the whole 'structure' index.\n *\n * @param {Graph} graph - Target Graph instance.\n */\nexport function clearStructureIndex(graph) {\n  const iterator = graph._nodes.values();\n\n  let step;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    step.value.clear();\n  }\n}\n\n/**\n * Function used to upgrade a simple `structure` index to a multi on.\n *\n * @param {Graph}  graph - Target Graph instance.\n */\nexport function upgradeStructureIndexToMulti(graph) {\n  graph._nodes.forEach((data, node) => {\n    // Directed\n    if (data.out) {\n      for (const neighbor in data.out) {\n        const edges = new Set();\n        edges.add(data.out[neighbor]);\n        data.out[neighbor] = edges;\n        graph._nodes.get(neighbor).in[node] = edges;\n      }\n    }\n\n    // Undirected\n    if (data.undirected) {\n      for (const neighbor in data.undirected) {\n        if (neighbor > node) continue;\n\n        const edges = new Set();\n        edges.add(data.undirected[neighbor]);\n        data.undirected[neighbor] = edges;\n        graph._nodes.get(neighbor).undirected[node] = edges;\n      }\n    }\n  });\n}\n","/**\n * Graphology Node Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject} from '../utils';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\nconst NODE = 0;\nconst SOURCE = 1;\nconst TARGET = 2;\nconst OPPOSITE = 3;\n\nfunction findRelevantNodeData(\n  graph,\n  method,\n  mode,\n  nodeOrEdge,\n  nameOrEdge,\n  add1,\n  add2\n) {\n  let nodeData, edgeData, arg1, arg2;\n\n  nodeOrEdge = '' + nodeOrEdge;\n\n  if (mode === NODE) {\n    nodeData = graph._nodes.get(nodeOrEdge);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" node in the graph.`\n      );\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  } else if (mode === OPPOSITE) {\n    nameOrEdge = '' + nameOrEdge;\n\n    edgeData = graph._edges.get(nameOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nameOrEdge}\" edge in the graph.`\n      );\n\n    const source = edgeData.source.key;\n    const target = edgeData.target.key;\n\n    if (nodeOrEdge === source) {\n      nodeData = edgeData.target;\n    } else if (nodeOrEdge === target) {\n      nodeData = edgeData.source;\n    } else {\n      throw new NotFoundGraphError(\n        `Graph.${method}: the \"${nodeOrEdge}\" node is not attached to the \"${nameOrEdge}\" edge (${source}, ${target}).`\n      );\n    }\n\n    arg1 = add1;\n    arg2 = add2;\n  } else {\n    edgeData = graph._edges.get(nodeOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" edge in the graph.`\n      );\n\n    if (mode === SOURCE) {\n      nodeData = edgeData.source;\n    } else {\n      nodeData = edgeData.target;\n    }\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  }\n\n  return [nodeData, arg1, arg2];\n}\n\nfunction attachNodeAttributeGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes[name];\n  };\n}\n\nfunction attachNodeAttributesGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {\n    const [data] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge\n    );\n\n    return data.attributes;\n  };\n}\n\nfunction attachNodeAttributeChecker(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\nfunction attachNodeAttributeSetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, value] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeRemover(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesReplacer(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesMerger(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst NODE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachNodeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachNodeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachNodeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachNodeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachNodeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachNodeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachNodeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachNodeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachNodeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachNodeAttributesMethods(Graph) {\n  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For nodes\n    attacher(Graph, name('Node'), NODE);\n\n    // For sources\n    attacher(Graph, name('Source'), SOURCE);\n\n    // For targets\n    attacher(Graph, name('Target'), TARGET);\n\n    // For opposites\n    attacher(Graph, name('Opposite'), OPPOSITE);\n  });\n}\n","/**\n * Graphology Edge Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject, getMatchingEdge} from '../utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from '../errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesMerger(Class, method, type) {\n  /**\n   * Merge the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesUpdater(Class, method, type) {\n  /**\n   * Update the attributes of the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + updater;\n\n      updater = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst EDGE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachEdgeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachEdgeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachEdgeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachEdgeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachEdgeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachEdgeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachEdgeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachEdgeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachEdgeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachEdgeAttributesMethods(Graph) {\n  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n","/**\n * Obliterator Chain Function\n * ===========================\n *\n * Variadic function combining the given iterables.\n */\nvar Iterator = require('./iterator.js'),\n  iter = require('./iter.js');\n\n/**\n * Chain.\n *\n * @param  {...Iterator} iterables - Target iterables.\n * @return {Iterator}\n */\nmodule.exports = function chain() {\n  var iterables = arguments,\n    current,\n    i = -1;\n\n  return new Iterator(function iterate() {\n    if (!current) {\n      i++;\n\n      if (i >= iterables.length) return {done: true};\n\n      current = iter(iterables[i]);\n    }\n\n    var step = current.next();\n\n    if (step.done) {\n      current = null;\n      return iterate();\n    }\n\n    return step;\n  });\n};\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function collecting edges from the given object.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @return {array}         - The found edges.\n */\nfunction collectSimple(edges, object) {\n  for (const k in object) edges.push(object[k].key);\n}\n\nfunction collectMulti(edges, object) {\n  for (const k in object)\n    object[k].forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over edges from the given object using a callback.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n  }\n}\n\nfunction forEachMulti(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    object[k].forEach(edgeData =>\n      callback(\n        edgeData.key,\n        edgeData.attributes,\n        edgeData.source.key,\n        edgeData.target.key,\n        edgeData.source.attributes,\n        edgeData.target.attributes,\n        edgeData.undirected\n      )\n    );\n  }\n}\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction findSimple(object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction findMulti(object, callback, avoid) {\n  let iterator, step, edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    iterator = object[k].values();\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (shouldBreak) return edgeData.key;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object),\n    l = keys.length;\n\n  let inner = null,\n    i = 0;\n\n  return new Iterator(function next() {\n    let edgeData;\n\n    if (inner) {\n      const step = inner.next();\n\n      if (step.done) {\n        inner = null;\n        i++;\n        return next();\n      }\n\n      edgeData = step.value;\n    } else {\n      if (i >= l) return {done: true};\n\n      const k = keys[i];\n\n      if (k === avoid) {\n        i++;\n        return next();\n      }\n\n      edgeData = object[k];\n\n      if (edgeData instanceof Set) {\n        inner = edgeData.values();\n        return next();\n      }\n\n      i++;\n    }\n\n    return {\n      done: false,\n      value: {\n        edge: edgeData.key,\n        attributes: edgeData.attributes,\n        source: edgeData.source.key,\n        target: edgeData.target.key,\n        sourceAttributes: edgeData.source.attributes,\n        targetAttributes: edgeData.target.attributes,\n        undirected: edgeData.undirected\n      }\n    };\n  });\n}\n\n/**\n * Function collecting edges from the given object at given key.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @param  {mixed}  k      - Neighbor key.\n * @return {array}         - The found edges.\n */\nfunction collectForKeySimple(edges, object, k) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  edges.push(edgeData.key);\n}\n\nfunction collectForKeyMulti(edges, object, k) {\n  const edgesData = object[k];\n\n  if (!edgesData) return;\n\n  edgesData.forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  callback(\n    edgeData.key,\n    edgeData.attributes,\n    sourceData.key,\n    targetData.key,\n    sourceData.attributes,\n    targetData.attributes,\n    edgeData.undirected\n  );\n}\n\nfunction forEachForKeyMulti(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData) return;\n\n  edgesData.forEach(edgeData =>\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    )\n  );\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction findForKeySimple(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    )\n  )\n    return edgeData.key;\n}\n\nfunction findForKeyMulti(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData) return;\n\n  let shouldBreak = false;\n\n  const iterator = edgesData.values();\n  let step, edgeData;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    edgeData = step.value;\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  const v = object[k];\n\n  if (v instanceof Set) {\n    const iterator = v.values();\n\n    return new Iterator(function () {\n      const step = iterator.next();\n\n      if (step.done) return step;\n\n      const edgeData = step.value;\n\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    });\n  }\n\n  return Iterator.of([\n    v.key,\n    v.attributes,\n    v.source.key,\n    v.target.key,\n    v.source.attributes,\n    v.target.attributes\n  ]);\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    if (typeof Array.from === 'function')\n      return Array.from(graph._edges.keys());\n\n    return take(graph._edges.keys(), graph._edges.size);\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n  }\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction findEdge(graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return Iterator.empty();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    let step, data;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      step = iterator.next();\n\n      if (step.done) return step;\n\n      data = step.value;\n\n      if (shouldFilter && data.undirected !== mask) continue;\n\n      break;\n    }\n\n    const value = {\n      edge: data.key,\n      attributes: data.attributes,\n      source: data.source.key,\n      target: data.target.key,\n      sourceAttributes: data.source.attributes,\n      targetAttributes: data.target.attributes,\n      undirected: data.undirected\n    };\n\n    return {value, done: false};\n  });\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = [];\n\n  const fn = multi ? collectMulti : collectSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') fn(edges, nodeData.in);\n    if (direction !== 'in') fn(edges, nodeData.out);\n\n    // Handling self loop edge case\n    if (!direction && nodeData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(nodeData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    fn(edges, nodeData.undirected);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') fn(nodeData.in, callback);\n    if (direction !== 'in')\n      fn(nodeData.out, callback, !direction ? nodeData.key : null);\n  }\n\n  if (type !== 'directed') {\n    fn(nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction findEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? findMulti : findSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(nodeData.in, callback);\n\n      if (found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(nodeData.out, callback, !direction ? nodeData.key : null);\n\n      if (found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(nodeData.undirected, callback);\n\n    if (found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : null)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const fn = multi ? collectForKeyMulti : collectForKeySimple;\n\n  const edges = [];\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(edges, sourceData.in, target);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      fn(edges, sourceData.out, target);\n\n    // Handling self loop edge case\n    if (!direction && sourceData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(sourceData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(edges, sourceData.undirected, target);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over edges for the given path using a callback.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(sourceData.in, target, callback);\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n        fn(sourceData.out, target, callback);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(sourceData.undirected, target, callback);\n  }\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction findEdgeForPath(type, multi, direction, sourceData, target, callback) {\n  const fn = multi ? findForKeyMulti : findForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(sourceData.in, target, callback);\n\n      if (found) return found;\n    }\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in') {\n        found = fn(\n          sourceData.out,\n          target,\n          callback,\n          !direction ? sourceData.key : null\n        );\n\n        if (found) return found;\n      }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(sourceData.undirected, target, callback);\n\n      if (found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return findEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return findEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return findEdgeForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {NotFoundGraphError, InvalidArgumentsGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function merging neighbors into the given set iterating over the given object.\n *\n * @param {BasicSet} neighbors - Neighbors set.\n * @param {object}   object    - Target object.\n */\nfunction merge(neighbors, object) {\n  if (typeof object === 'undefined') return;\n\n  for (const neighbor in object) neighbors.add(neighbor);\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const neighbors = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      merge(neighbors, nodeData.in);\n    }\n    if (direction !== 'in') {\n      merge(neighbors, nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    merge(neighbors, nodeData.undirected);\n  }\n\n  return take(neighbors.values(), neighbors.size);\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    callback(neighborData.key, neighborData.attributes);\n  }\n}\n\nfunction forEachInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key)) continue;\n\n    visited.add(neighborData.key);\n\n    callback(neighborData.key, neighborData.attributes);\n  }\n}\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction findInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction findInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key)) continue;\n\n    visited.add(neighborData.key);\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighborForNode(type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      forEachInObjectOnce(visited, nodeData, nodeData.in, callback);\n    }\n    if (direction !== 'in') {\n      forEachInObjectOnce(visited, nodeData, nodeData.out, callback);\n    }\n  }\n\n  if (type !== 'directed') {\n    forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n  }\n}\n\nfunction findNeighbor(type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return findInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return findInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = findInObjectOnce(visited, nodeData, nodeData.in, callback);\n\n      if (found) return found;\n    }\n    if (direction !== 'in') {\n      found = findInObjectOnce(visited, nodeData, nodeData.out, callback);\n\n      if (found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = findInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n\n    if (found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createObjectIterator(nodeData, object) {\n  const keys = Object.keys(object),\n    l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    return {\n      done: false,\n      value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n    };\n  });\n}\n\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object),\n    l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    if (i >= l) return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key)) return next();\n\n    visited.add(neighborData.key);\n\n    return {\n      done: false,\n      value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createObjectIterator(nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createObjectIterator(nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighborForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return findNeighbor(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Adjacency Iteration\n * ================================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nexport function forEachAdjacencySimple(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        hasEdges = true;\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected\n        );\n\n        if (breakable && shouldBreak) return edgeData;\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        if (targetData.key !== neighbor) targetData = edgeData.source;\n\n        hasEdges = true;\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected\n        );\n\n        if (breakable && shouldBreak) return edgeData;\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function iterating over a multi graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nexport function forEachAdjacencyMulti(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step;\n  let sourceData;\n  let neighbor;\n  let container;\n  let containerStep;\n  let adj;\n  let edgeData;\n  let targetData;\n  let shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        container = adj[neighbor].values();\n\n        while (\n          ((containerStep = container.next()), containerStep.done !== true)\n        ) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n        }\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        container = adj[neighbor].values();\n\n        while (\n          ((containerStep = container.next()), containerStep.done !== true)\n        ) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n        }\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n\n// export function createAdjacencyIteratorSimple(graph) {\n//   const iterator = graph._nodes.values();\n\n//   const type = graph.type;\n\n//   let state = 'outer',\n//     sourceData,\n//     neighbors,\n//     adj,\n//     offset;\n\n//   return new Iterator(function next() {\n//     let step;\n\n//     if (state === 'outer') {\n//       step = iterator.next();\n\n//       if (step.done === true) return step;\n\n//       sourceData = step.value;\n\n//       state = 'directed';\n//       return next();\n//     }\n\n//     if (state === 'directed') {\n//       if (type === 'undirected') {\n//         state = 'undirected';\n//         return next();\n//       }\n\n//       adj = sourceData.out;\n//       neighbors = Object.keys(sourceData.out);\n//       offset = 0;\n//       state = 'inner-directed';\n\n//       return next();\n//     }\n\n//     if (state === 'undirected') {\n//       if (type === 'directed') {\n//         state = 'outer';\n//         return next();\n//       }\n\n//       adj = sourceData.undirected;\n//       neighbors = Object.keys(sourceData.undirected);\n//       offset = 0;\n//       state = 'inner-undirected';\n//     }\n\n//     // Inner\n//     if (offset >= neighbors.length) {\n//       if (state === 'inner-undirected') state = 'outer';\n//       else state = 'undirected';\n\n//       return next();\n//     }\n\n//     const neighbor = neighbors[offset++];\n//     const edgeData = adj[neighbor];\n//     let targetData = edgeData.target;\n\n//     if (state === 'inner-undirected' && targetData.key === sourceData.key)\n//       targetData = edgeData.source;\n\n//     return {\n//       done: false,\n//       value: {\n//         source: sourceData.key,\n//         target: targetData.key,\n//         sourceAttributes: sourceData.attributes,\n//         targetAttributes: targetData.attributes,\n//         edgeKey: edgeData.key,\n//         edgeAttributes: edgeData.attributes,\n//         undirected: edgeData.undirected\n//       }\n//     };\n//   });\n// }\n\n// export function createAdjacencyIteratorMulti(graph) {\n//   const iterator = graph._nodes.values();\n\n//   const type = graph.type;\n\n//   let state = 'outer',\n//     sourceData,\n//     neighbors,\n//     container = null,\n//     adj,\n//     offset;\n\n//   return new Iterator(function next() {\n//     let step;\n\n//     if (state === 'outer') {\n//       step = iterator.next();\n\n//       if (step.done === true) return step;\n\n//       sourceData = step.value;\n\n//       state = 'directed';\n//       return next();\n//     }\n\n//     if (state === 'directed') {\n//       if (type === 'undirected') {\n//         state = 'undirected';\n//         return next();\n//       }\n\n//       adj = sourceData.out;\n//       neighbors = Object.keys(sourceData.out);\n//       offset = 0;\n//       state = 'inner-directed';\n\n//       return next();\n//     }\n\n//     if (state === 'undirected') {\n//       if (type === 'directed') {\n//         state = 'outer';\n//         return next();\n//       }\n\n//       adj = sourceData.undirected;\n//       neighbors = Object.keys(sourceData.undirected);\n//       offset = 0;\n//       state = 'inner-undirected';\n//     }\n\n//     // Inner\n//     if (!container && offset >= neighbors.length) {\n//       if (state === 'inner-undirected') state = 'outer';\n//       else state = 'undirected';\n\n//       return next();\n//     }\n\n//     if (!container) {\n//       const neighbor = neighbors[offset++];\n//       container = adj[neighbor].values();\n//       return next();\n//     }\n\n//     step = container.next();\n\n//     if (step.done) {\n//       container = null;\n//       return next();\n//     }\n\n//     const edgeData = step.value;\n//     let targetData = edgeData.target;\n\n//     if (state === 'inner-undirected' && targetData.key === sourceData.key)\n//       targetData = edgeData.source;\n\n//     return {\n//       done: false,\n//       value: {\n//         source: sourceData.key,\n//         target: targetData.key,\n//         sourceAttributes: sourceData.attributes,\n//         targetAttributes: targetData.attributes,\n//         edge: edgeData.key,\n//         edgeAttributes: edgeData.attributes,\n//         undirected: edgeData.undirected\n//       }\n//     };\n//   });\n// }\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used to validate import-export formats & to ouput\n * them from internal graph data.\n *\n * Serialized Node:\n * {key, ?attributes}\n *\n * Serialized Edge:\n * {key?, source, target, attributes?, undirected?}\n *\n * Serialized Graph:\n * {nodes[], edges?[]}\n */\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value)) return 'not-object';\n\n  if (!('key' in value)) return 'no-key';\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    return 'invalid-attributes';\n\n  return null;\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value)) return 'not-object';\n\n  if (!('source' in value)) return 'no-source';\n\n  if (!('target' in value)) return 'no-target';\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    return 'invalid-attributes';\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    return 'invalid-undirected';\n\n  return null;\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport {\n  updateStructureIndex,\n  clearEdgeFromStructureIndex,\n  clearStructureIndex,\n  upgradeStructureIndexToMulti\n} from './indices';\n\nimport attachNodeAttributesMethods from './attributes/nodes';\nimport attachEdgeAttributesMethods from './attributes/edges';\nimport attachEdgeIterationMethods from './iteration/edges';\nimport attachNeighborIterationMethods from './iteration/neighbors';\nimport {\n  forEachAdjacencySimple,\n  forEachAdjacencyMulti\n} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isGraph,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalIdStartingFromRandomByte,\n  validateHints\n} from './utils';\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    } else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  } else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    } else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source);\n  let targetData = graph._nodes.get(target);\n  let edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are coherent\n      if (\n        edgeData.source.key !== source ||\n        edgeData.target.key !== target ||\n        (undirected &&\n          (edgeData.source.key !== target || edgeData.target.key !== source))\n      ) {\n        throw new UsageGraphError(\n          `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n        );\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    const info = [alreadyExistingEdgeData.key, false, false, false];\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return info;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return info;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  let sourceWasAdded = false;\n  let targetWasAdded = false;\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n    sourceWasAdded = true;\n\n    if (source === target) {\n      targetData = sourceData;\n      targetWasAdded = true;\n    }\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n    targetWasAdded = true;\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    } else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  } else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    } else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return [edge, true, sourceWasAdded, targetWasAdded];\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instanceId = INSTANCE_ID();\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = 'geid_' + instanceId + '_' + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.out[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.undirected[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n\n      if (!edges)\n        edges =\n          typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.directedSelfLoops;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree + nodeData.directedSelfLoops;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    const loops = nodeData.directedSelfLoops;\n\n    const inDegree = nodeData.inDegree + loops;\n    const outDegree = nodeData.outDegree + loops;\n\n    return inDegree + outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    const loops = nodeData.undirectedSelfLoops;\n\n    return nodeData.undirectedDegree + loops * 2;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree + nodeData.undirectedSelfLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree +=\n        nodeData.inDegree + nodeData.outDegree + nodeData.directedSelfLoops * 2;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key;\n    const target = data.target.key;\n\n    if (node === source) return target;\n    if (node === target) return source;\n\n    throw new NotFoundGraphError(\n      `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n    );\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return [node, false];\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return [node, false];\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Removing attached edges\n    // TODO: we could do faster\n    this.forEachEdge(node, edge => {\n      this.dropEdge(edge);\n    });\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0],\n        target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    // Dropping the edge from the register\n    this._edges.delete(edgeData.key);\n\n    // Updating related degrees\n    const {source: sourceData, target: targetData, attributes} = edgeData;\n\n    const undirected = edgeData.undirected;\n\n    if (sourceData === targetData) {\n      if (undirected) {\n        sourceData.undirectedSelfLoops--;\n        this._undirectedSelfLoopCount--;\n      } else {\n        sourceData.directedSelfLoops--;\n        this._directedSelfLoopCount--;\n      }\n    } else {\n      if (undirected) {\n        sourceData.undirectedDegree--;\n        targetData.undirectedDegree--;\n      } else {\n        sourceData.outDegree--;\n        targetData.inDegree--;\n      }\n    }\n\n    // Clearing index\n    clearEdgeFromStructureIndex(this, undirected, edgeData);\n\n    if (undirected) this._undirectedSize--;\n    else this._directedSize--;\n\n    // Emitting\n    this.emit('edgeDropped', {\n      key: edge,\n      attributes,\n      source: sourceData.key,\n      target: targetData.key,\n      undirected\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    clearStructureIndex(this);\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method updating the graph's attributes.\n   *\n   * @param  {function} updater - Function used to update the attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given updater is not a function.\n   */\n  updateAttributes(updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttributes: provided updater is not a function.'\n      );\n\n    this._attributes = updater(this._attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'update',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData, sourceData, targetData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      sourceData = edgeData.source;\n      targetData = edgeData.target;\n\n      edgeData.attributes = updater(\n        edgeData.key,\n        edgeData.attributes,\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.undirected\n      );\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntry: expecting a callback.'\n      );\n\n    if (this.multi) forEachAdjacencyMulti(false, false, false, this, callback);\n    else forEachAdjacencySimple(false, false, false, this, callback);\n  }\n  forEachAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    if (this.multi) forEachAdjacencyMulti(false, false, true, this, callback);\n    else forEachAdjacencySimple(false, false, true, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's assymetric adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAssymetricAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'\n      );\n\n    if (this.multi) forEachAdjacencyMulti(false, true, false, this, callback);\n    else forEachAdjacencySimple(false, true, false, this, callback);\n  }\n  forEachAssymetricAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    if (this.multi) forEachAdjacencyMulti(false, true, true, this, callback);\n    else forEachAdjacencySimple(false, true, true, this, callback);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    if (typeof Array.from === 'function') return Array.from(this._nodes.keys());\n\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done) return step;\n\n      const data = step.value;\n\n      return {\n        value: {node: data.key, attributes: data.attributes},\n        done: false\n      };\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method exporting the target node.\n   *\n   * @param  {any}   node - Target node.\n   * @return {array}      - The serialized node.\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  exportNode(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.exportNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    return serializeNode(node, data);\n  }\n\n  /**\n   * Method exporting the target edge.\n   *\n   * @param  {any}   edge - Target edge.\n   * @return {array}      - The serialized edge.\n   *\n   * @throws {Error} - Will throw if the edge is not found.\n   */\n  exportEdge(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.exportEdge: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return serializeEdge(edge, data);\n  }\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(key, data);\n    });\n\n    return {\n      attributes: this.getAttributes(),\n      nodes,\n      edges,\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      }\n    };\n  }\n\n  /**\n   * Method used to import a serialized node.\n   *\n   * @param  {object} data   - The serialized node.\n   * @param  {boolean} merge - Whether to merge the given node.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importNode(data, merge = false) {\n    // Validating\n    const error = validateSerializedNode(data);\n\n    if (error) {\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n        );\n      if (error === 'no-key')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importNode: no key provided.'\n        );\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.'\n        );\n    }\n\n    // Adding the node\n    const {key, attributes = {}} = data;\n\n    if (merge) this.mergeNode(key, attributes);\n    else this.addNode(key, attributes);\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized edge.\n   *\n   * @param  {object}  data  - The serialized edge.\n   * @param  {boolean} merge - Whether to merge the given edge.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importEdge(data, merge = false) {\n    // Validating\n    const error = validateSerializedEdge(data);\n\n    if (error) {\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n        );\n      if (error === 'no-source')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: missing souce.'\n        );\n      if (error === 'no-target')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: missing target.'\n        );\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.'\n        );\n      if (error === 'invalid-undirected')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.'\n        );\n    }\n\n    // Adding the edge\n    const {source, target, attributes = {}, undirected = false} = data;\n\n    let method;\n\n    if ('key' in data) {\n      method = merge\n        ? undirected\n          ? this.mergeUndirectedEdgeWithKey\n          : this.mergeDirectedEdgeWithKey\n        : undirected\n        ? this.addUndirectedEdgeWithKey\n        : this.addDirectedEdgeWithKey;\n\n      method.call(this, data.key, source, target, attributes);\n    } else {\n      method = merge\n        ? undirected\n          ? this.mergeUndirectedEdge\n          : this.mergeDirectedEdge\n        : undirected\n        ? this.addUndirectedEdge\n        : this.addDirectedEdge;\n\n      method.call(this, source, target, attributes);\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance\n    if (isGraph(data)) {\n      this.import(data.export(), merge);\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) this.importNode(list[i], merge);\n    }\n\n    if (data.edges) {\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) this.importEdge(list[i], merge);\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n    graph.replaceAttributes(assign({}, this.getAttributes()));\n    return graph;\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @return {Graph} - The copy.\n   */\n  copy() {\n    const graph = this.emptyCopy();\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      addEdge(\n        graph,\n        'copy',\n        false,\n        edgeData.undirected,\n        edgeData.key,\n        edgeData.source.key,\n        edgeData.target.key,\n        assign({}, edgeData.attributes)\n      );\n    }\n\n    return graph;\n  }\n\n  /**\n   * Method upgrading the graph to a mixed one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMixed() {\n    if (this.type === 'mixed') return this;\n\n    // Upgrading node data:\n    // NOTE: maybe this could lead to some de-optimization by usual\n    // JavaScript engines but I cannot be sure of it. Another solution\n    // would be to reinstantiate the classes but this surely has a performance\n    // and memory impact.\n    this._nodes.forEach(data => data.upgradeToMixed());\n\n    // Mutating the options & the instance\n    this._options.type = 'mixed';\n    readOnlyProperty(this, 'type', this._options.type);\n    privateProperty(this, 'NodeDataClass', MixedNodeData);\n\n    return this;\n  }\n\n  /**\n   * Method upgrading the graph to a multi one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMulti() {\n    if (this.multi) return this;\n\n    // Mutating the options & the instance\n    this._options.multi = true;\n    readOnlyProperty(this, 'multi', true);\n\n    // Upgrading indices\n    upgradeStructureIndexToMulti(this);\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function' &&\n        typeof k !== 'symbol'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Attributes-related.\n */\nattachNodeAttributesMethods(Graph);\nattachEdgeAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n","/**\n * Graphology CommonJS Endoint\n * ============================\n *\n * Endpoint for CommonJS modules consumers.\n */\nimport {Graph} from './classes';\n\nexport default Graph;\n"],"names":["assignPolyfill","target","arguments","i","l","length","k","assign","Object","getMatchingEdge","graph","source","type","sourceData","_nodes","get","edge","out","undirected","isGraph","value","addUndirectedEdgeWithKey","dropNode","isPlainObject","constructor","isEmpty","o","privateProperty","name","defineProperty","enumerable","configurable","writable","readOnlyProperty","descriptor","validateHints","hints","attributes","Array","isArray","incrementalIdStartingFromRandomByte","Math","floor","random","R","Reflect","ReflectApply","apply","receiver","args","Function","prototype","call","ReflectOwnKeys","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","ProcessEmitWarning","warning","console","warn","NumberIsNaN","Number","isNaN","EventEmitter","init","eventsModule","once","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","set","arg","RangeError","getPrototypeOf","create","setMaxListeners","n","_getMaxListeners","that","getMaxListeners","emit","push","doError","events","error","er","Error","err","message","context","handler","len","listeners","arrayClone","_addListener","prepend","m","existing","newListener","unshift","warned","w","String","emitter","count","addListener","on","prependListener","onceWrapper","fired","removeListener","wrapFn","_onceWrap","state","wrapped","bind","prependOnceListener","list","position","originalListener","shift","spliceOne","off","removeAllListeners","keys","key","_listeners","unwrap","evlistener","unwrapListeners","rawListeners","listenerCount","eventNames","arr","copy","index","pop","ret","Promise","resolve","reject","errorListener","resolver","slice","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","addEventListener","wrapListener","removeEventListener","Iterator","next","Symbol","iterator","of","done","empty","fromSequence","sequence","is","ArrayBuffer","require$$0","support","require$$1","ARRAY_BUFFER_SUPPORT","SYMBOL_SUPPORT","iterOrNull","isView","iter","take","iterable","Infinity","array","step","GraphError","InvalidArgumentsGraphError","captureStackTrace","NotFoundGraphError","UsageGraphError","MixedNodeData","clear","inDegree","outDegree","undirectedDegree","directedSelfLoops","undirectedSelfLoops","DirectedNodeData","upgradeToMixed","UndirectedNodeData","EdgeData","updateStructureIndex","edgeData","targetData","multi","outKey","inKey","adj","container","Set","add","clearEdgeFromStructureIndex","sourceIndex","size","targetIndex","clearStructureIndex","values","upgradeStructureIndexToMulti","forEach","data","node","neighbor","edges","NODE","SOURCE","TARGET","OPPOSITE","findRelevantNodeData","method","mode","nodeOrEdge","nameOrEdge","add1","add2","nodeData","arg1","arg2","_edges","attachNodeAttributeGetter","Class","attachNodeAttributesGetter","attachNodeAttributeChecker","hasOwnProperty","attachNodeAttributeSetter","attachNodeAttributeUpdater","updater","attachNodeAttributeRemover","attachNodeAttributesReplacer","attachNodeAttributesMerger","attachNodeAttributesUpdater","NODE_ATTRIBUTES_METHODS","element","attacher","attachNodeAttributesMethods","Graph","attachEdgeAttributeGetter","attachEdgeAttributesGetter","attachEdgeAttributeChecker","attachEdgeAttributeSetter","attachEdgeAttributeUpdater","attachEdgeAttributeRemover","attachEdgeAttributesReplacer","attachEdgeAttributesMerger","attachEdgeAttributesUpdater","EDGE_ATTRIBUTES_METHODS","attachEdgeAttributesMethods","chain","iterables","current","iterate","EDGES_ITERATION","direction","collectSimple","object","collectMulti","forEachSimple","callback","avoid","forEachMulti","findSimple","shouldBreak","findMulti","createIterator","inner","sourceAttributes","targetAttributes","collectForKeySimple","collectForKeyMulti","edgesData","forEachForKeySimple","forEachForKeyMulti","findForKeySimple","findForKeyMulti","createIteratorForKey","v","createEdgeArray","from","undirectedSize","directedSize","mask","forEachEdge","shouldFilter","findEdge","createEdgeIterator","createEdgeArrayForNode","fn","splice","lastIndexOf","forEachEdgeForNode","findEdgeForNode","found","createEdgeIteratorForNode","createEdgeArrayForPath","forEachEdgeForPath","findEdgeForPath","createEdgeIteratorForPath","attachEdgeArrayCreator","description","has","attachForEachEdge","forEachName","toUpperCase","mapName","result","e","ea","s","t","sa","ta","u","filterName","reduceName","initialValue","accumulator","attachFindEdge","findEdgeName","someName","everyName","attachEdgeIteratorCreator","originalName","attachEdgeIterationMethods","NEIGHBORS_ITERATION","merge","neighbors","createNeighborArrayForNode","forEachInObject","neighborData","forEachInObjectOnce","visited","findInObject","findInObjectOnce","forEachNeighborForNode","findNeighbor","createObjectIterator","createDedupedObjectIterator","createNeighborIterator","attachNeighborArrayCreator","attachForEachNeighbor","a","attachFindNeighbor","capitalizedSingular","findName","attachNeighborIteratorCreator","iteratorName","attachNeighborIterationMethods","forEachAdjacencySimple","breakable","assymetric","disconnectedNodes","hasEdges","forEachAdjacencyMulti","containerStep","serializeNode","serialized","serializeEdge","validateSerializedNode","validateSerializedEdge","INSTANCE_ID","TYPES","EMITTER_PROPS","EDGE_ADD_METHODS","verb","generateKey","DEFAULTS","allowSelfLoops","addNode","NodeDataClass","unsafeAddNode","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","_undirectedSelfLoopCount","_directedSelfLoopCount","_undirectedSize","_directedSize","mergeEdge","asUpdater","alreadyExistingEdgeData","info","oldAttributes","sourceWasAdded","targetWasAdded","options","instanceId","edgeId","edgeKeyGenerator","availableEdgeKey","Map","prop","_options","_resetInstanceCounters","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undirectedEdge","areDirectedNeighbors","areOutNeighbors","areInNeighbors","areUndirectedNeighbors","areNeighbors","areInboundNeighbors","areOutboundNeighbors","directedDegree","loops","degree","inDegreeWithoutSelfLoops","outDegreeWithoutSelfLoops","directedDegreeWithoutSelfLoops","undirectedDegreeWithoutSelfLoops","degreeWithoutSelfLoops","extremities","opposite","hasExtremity","isUndirected","isDirected","isSelfLoop","mergeNode","updateNode","dropEdge","clearEdges","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","updateAttributes","updateEachNodeAttributes","updateEachEdgeAttributes","forEachAdjacencyEntry","forEachAdjacencyEntryWithOrphans","forEachAssymetricAdjacencyEntry","forEachAssymetricAdjacencyEntryWithOrphans","nodes","forEachNode","findNode","mapNodes","order","someNode","everyNode","filterNodes","reduceNodes","nodeEntries","exportNode","exportEdge","importNode","importEdge","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addDirectedEdgeWithKey","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","upgradeToMulti","toJSON","toString","inspect","multiIndex","label","tmp","desc","startsWith","dummy","DirectedGraph","finalOptions","UndirectedGraph","MultiGraph","MultiDirectedGraph","MultiUndirectedGraph","attachStaticFromMethod","instance"],"mappings":"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"}