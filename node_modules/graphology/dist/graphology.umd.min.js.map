{"version":3,"file":"graphology.umd.min.js","sources":["../src/utils.js","../../../node_modules/events/events.js","../../../node_modules/obliterator/iterator.js","../../../node_modules/obliterator/support.js","../../../node_modules/obliterator/iter.js","../../../node_modules/obliterator/take.js","../src/errors.js","../src/data.js","../src/indices.js","../src/attributes/nodes.js","../src/attributes/edges.js","../../../node_modules/obliterator/chain.js","../src/iteration/edges.js","../src/iteration/neighbors.js","../src/iteration/adjacency.js","../src/serialization.js","../src/graph.js","../src/classes.js"],"sourcesContent":["/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a Graph implementation instance.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function'\n  );\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' && value !== null && value.constructor === Object\n  );\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n  if (typeof next !== 'function')\n    throw new Error('obliterator/iterator: expecting a function!');\n\n  this.next = next;\n}\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function () {\n  var args = arguments,\n    l = args.length,\n    i = 0;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function () {\n  var iterator = new Iterator(function () {\n    return {done: true};\n  });\n\n  return iterator;\n};\n\n/**\n * Returning an iterator over the given indexed sequence.\n *\n * @param  {string|Array} sequence - Target sequence.\n * @return {Iterator}\n */\nIterator.fromSequence = function (sequence) {\n  var i = 0,\n    l = sequence.length;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: sequence[i++]};\n  });\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function (value) {\n  if (value instanceof Iterator) return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n","exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== 'undefined';\nexports.SYMBOL_SUPPORT = typeof Symbol !== 'undefined';\n","/**\n * Obliterator Iter Function\n * ==========================\n *\n * Function coercing values to an iterator. It can be quite useful when needing\n * to handle iterables and iterators the same way.\n */\nvar Iterator = require('./iterator.js');\nvar support = require('./support.js');\n\nvar ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;\nvar SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;\n\nfunction iterOrNull(target) {\n  // Indexed sequence\n  if (\n    typeof target === 'string' ||\n    Array.isArray(target) ||\n    (ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(target))\n  )\n    return Iterator.fromSequence(target);\n\n  // Invalid value\n  if (typeof target !== 'object' || target === null) return null;\n\n  // Iterable\n  if (SYMBOL_SUPPORT && typeof target[Symbol.iterator] === 'function')\n    return target[Symbol.iterator]();\n\n  // Iterator duck-typing\n  if (typeof target.next === 'function') return target;\n\n  // Invalid object\n  return null;\n}\n\nmodule.exports = function iter(target) {\n  var iterator = iterOrNull(target);\n\n  if (!iterator)\n    throw new Error(\n      'obliterator: target is not iterable nor a valid iterator.'\n    );\n\n  return iterator;\n};\n","/* eslint no-constant-condition: 0 */\n/**\n * Obliterator Take Function\n * ==========================\n *\n * Function taking n or every value of the given iterator and returns them\n * into an array.\n */\nvar iter = require('./iter.js');\n\n/**\n * Take.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {number}   [n]      - Optional number of items to take.\n * @return {array}\n */\nmodule.exports = function take(iterable, n) {\n  var l = arguments.length > 1 ? n : Infinity,\n    array = l !== Infinity ? new Array(l) : [],\n    step,\n    i = 0;\n\n  var iterator = iter(iterable);\n\n  while (true) {\n    if (i === l) return array;\n\n    step = iterator.next();\n\n    if (step.done) {\n      if (i !== n) array.length = i;\n\n      return array;\n    }\n\n    array[i++] = step.value;\n  }\n};\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.directedSelfLoops = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\nDirectedNodeData.prototype.upgradeToMixed = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\nUndirectedNodeData.prototype.upgradeToMixed = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n","/**\n * Graphology Indexes Functions\n * =============================\n *\n * Bunch of functions used to compute or clear indexes.\n */\n\n/**\n * Function updating the 'structure' index with the given edge's data.\n * Note that in the case of the multi graph, related edges are stored in a\n * set that is the same for A -> B & B <- A.\n *\n * @param {Graph}    graph      - Target Graph instance.\n * @param {EdgeData} edgeData   - Added edge's data.\n * @param {NodeData} sourceData - Source node's data.\n * @param {NodeData} targetData - Target node's data.\n */\nexport function updateStructureIndex(\n  graph,\n  undirected,\n  edgeData,\n  source,\n  target,\n  sourceData,\n  targetData\n) {\n  const multi = graph.multi;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (undirected) outKey = inKey = 'undirected';\n\n  let adj, container;\n\n  if (multi) {\n    // Handling source\n    adj = sourceData[outKey];\n    container = adj[target];\n\n    if (typeof container === 'undefined') {\n      container = new Set();\n      adj[target] = container;\n    }\n\n    container.add(edgeData);\n\n    // If selfLoop, we break here\n    if (source === target && undirected) return;\n\n    // Handling target (we won't add the edge because it was already taken\n    // care of with source above)\n    adj = targetData[inKey];\n    if (typeof adj[source] === 'undefined') adj[source] = container;\n  } else {\n    // Handling source\n    sourceData[outKey][target] = edgeData;\n\n    // If selfLoop, we break here\n    if (source === target && undirected) return;\n\n    // Handling target\n    targetData[inKey][source] = edgeData;\n  }\n}\n\n/**\n * Function clearing the 'structure' index data related to the given edge.\n *\n * @param {Graph}    graph    - Target Graph instance.\n * @param {EdgeData} edgeData - Dropped edge's data.\n */\nexport function clearEdgeFromStructureIndex(graph, undirected, edgeData) {\n  const multi = graph.multi;\n\n  const {source: sourceData, target: targetData} = edgeData;\n\n  const source = sourceData.key,\n    target = targetData.key;\n\n  // NOTE: since the edge set is the same for source & target, we can only\n  // affect source\n  const outKey = undirected ? 'undirected' : 'out',\n    sourceIndex = sourceData[outKey];\n\n  const inKey = undirected ? 'undirected' : 'in';\n\n  if (target in sourceIndex) {\n    if (multi) {\n      const set = sourceIndex[target];\n\n      if (set.size === 1) {\n        delete sourceIndex[target];\n        delete targetData[inKey][source];\n      } else {\n        set.delete(edgeData);\n      }\n    } else delete sourceIndex[target];\n  }\n\n  if (multi) return;\n\n  const targetIndex = targetData[inKey];\n\n  delete targetIndex[source];\n}\n\n/**\n * Function clearing the whole 'structure' index.\n *\n * @param {Graph} graph - Target Graph instance.\n */\nexport function clearStructureIndex(graph) {\n  const iterator = graph._nodes.values();\n\n  let step;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    step.value.clear();\n  }\n}\n\n/**\n * Function used to upgrade a simple `structure` index to a multi on.\n *\n * @param {Graph}  graph - Target Graph instance.\n */\nexport function upgradeStructureIndexToMulti(graph) {\n  graph._nodes.forEach((data, node) => {\n    // Directed\n    if (data.out) {\n      for (const neighbor in data.out) {\n        const edges = new Set();\n        edges.add(data.out[neighbor]);\n        data.out[neighbor] = edges;\n        graph._nodes.get(neighbor).in[node] = edges;\n      }\n    }\n\n    // Undirected\n    if (data.undirected) {\n      for (const neighbor in data.undirected) {\n        if (neighbor > node) continue;\n\n        const edges = new Set();\n        edges.add(data.undirected[neighbor]);\n        data.undirected[neighbor] = edges;\n        graph._nodes.get(neighbor).undirected[node] = edges;\n      }\n    }\n  });\n}\n","/**\n * Graphology Node Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject} from '../utils';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\nconst NODE = 0;\nconst SOURCE = 1;\nconst TARGET = 2;\nconst OPPOSITE = 3;\n\nfunction findRelevantNodeData(\n  graph,\n  method,\n  mode,\n  nodeOrEdge,\n  nameOrEdge,\n  add1,\n  add2\n) {\n  let nodeData, edgeData, arg1, arg2;\n\n  nodeOrEdge = '' + nodeOrEdge;\n\n  if (mode === NODE) {\n    nodeData = graph._nodes.get(nodeOrEdge);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" node in the graph.`\n      );\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  } else if (mode === OPPOSITE) {\n    nameOrEdge = '' + nameOrEdge;\n\n    edgeData = graph._edges.get(nameOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nameOrEdge}\" edge in the graph.`\n      );\n\n    const source = edgeData.source.key;\n    const target = edgeData.target.key;\n\n    if (nodeOrEdge === source) {\n      nodeData = edgeData.target;\n    } else if (nodeOrEdge === target) {\n      nodeData = edgeData.source;\n    } else {\n      throw new NotFoundGraphError(\n        `Graph.${method}: the \"${nodeOrEdge}\" node is not attached to the \"${nameOrEdge}\" edge (${source}, ${target}).`\n      );\n    }\n\n    arg1 = add1;\n    arg2 = add2;\n  } else {\n    edgeData = graph._edges.get(nodeOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" edge in the graph.`\n      );\n\n    if (mode === SOURCE) {\n      nodeData = edgeData.source;\n    } else {\n      nodeData = edgeData.target;\n    }\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  }\n\n  return [nodeData, arg1, arg2];\n}\n\nfunction attachNodeAttributeGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes[name];\n  };\n}\n\nfunction attachNodeAttributesGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {\n    const [data] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge\n    );\n\n    return data.attributes;\n  };\n}\n\nfunction attachNodeAttributeChecker(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\nfunction attachNodeAttributeSetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, value] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeRemover(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesReplacer(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesMerger(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst NODE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachNodeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachNodeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachNodeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachNodeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachNodeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachNodeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachNodeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachNodeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachNodeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachNodeAttributesMethods(Graph) {\n  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For nodes\n    attacher(Graph, name('Node'), NODE);\n\n    // For sources\n    attacher(Graph, name('Source'), SOURCE);\n\n    // For targets\n    attacher(Graph, name('Target'), TARGET);\n\n    // For opposites\n    attacher(Graph, name('Opposite'), OPPOSITE);\n  });\n}\n","/**\n * Graphology Edge Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject, getMatchingEdge} from '../utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from '../errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesMerger(Class, method, type) {\n  /**\n   * Merge the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesUpdater(Class, method, type) {\n  /**\n   * Update the attributes of the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + updater;\n\n      updater = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst EDGE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachEdgeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachEdgeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachEdgeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachEdgeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachEdgeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachEdgeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachEdgeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachEdgeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachEdgeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachEdgeAttributesMethods(Graph) {\n  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n","/**\n * Obliterator Chain Function\n * ===========================\n *\n * Variadic function combining the given iterables.\n */\nvar Iterator = require('./iterator.js'),\n  iter = require('./iter.js');\n\n/**\n * Chain.\n *\n * @param  {...Iterator} iterables - Target iterables.\n * @return {Iterator}\n */\nmodule.exports = function chain() {\n  var iterables = arguments,\n    current,\n    i = -1;\n\n  return new Iterator(function iterate() {\n    if (!current) {\n      i++;\n\n      if (i >= iterables.length) return {done: true};\n\n      current = iter(iterables[i]);\n    }\n\n    var step = current.next();\n\n    if (step.done) {\n      current = null;\n      return iterate();\n    }\n\n    return step;\n  });\n};\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function collecting edges from the given object.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @return {array}         - The found edges.\n */\nfunction collectSimple(edges, object) {\n  for (const k in object) edges.push(object[k].key);\n}\n\nfunction collectMulti(edges, object) {\n  for (const k in object)\n    object[k].forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over edges from the given object using a callback.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n  }\n}\n\nfunction forEachMulti(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    object[k].forEach(edgeData =>\n      callback(\n        edgeData.key,\n        edgeData.attributes,\n        edgeData.source.key,\n        edgeData.target.key,\n        edgeData.source.attributes,\n        edgeData.target.attributes,\n        edgeData.undirected\n      )\n    );\n  }\n}\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction findSimple(object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction findMulti(object, callback, avoid) {\n  let iterator, step, edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    iterator = object[k].values();\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (shouldBreak) return edgeData.key;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object),\n    l = keys.length;\n\n  let inner = null,\n    i = 0;\n\n  return new Iterator(function next() {\n    let edgeData;\n\n    if (inner) {\n      const step = inner.next();\n\n      if (step.done) {\n        inner = null;\n        i++;\n        return next();\n      }\n\n      edgeData = step.value;\n    } else {\n      if (i >= l) return {done: true};\n\n      const k = keys[i];\n\n      if (k === avoid) {\n        i++;\n        return next();\n      }\n\n      edgeData = object[k];\n\n      if (edgeData instanceof Set) {\n        inner = edgeData.values();\n        return next();\n      }\n\n      i++;\n    }\n\n    return {\n      done: false,\n      value: {\n        edge: edgeData.key,\n        attributes: edgeData.attributes,\n        source: edgeData.source.key,\n        target: edgeData.target.key,\n        sourceAttributes: edgeData.source.attributes,\n        targetAttributes: edgeData.target.attributes,\n        undirected: edgeData.undirected\n      }\n    };\n  });\n}\n\n/**\n * Function collecting edges from the given object at given key.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @param  {mixed}  k      - Neighbor key.\n * @return {array}         - The found edges.\n */\nfunction collectForKeySimple(edges, object, k) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  edges.push(edgeData.key);\n}\n\nfunction collectForKeyMulti(edges, object, k) {\n  const edgesData = object[k];\n\n  if (!edgesData) return;\n\n  edgesData.forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  callback(\n    edgeData.key,\n    edgeData.attributes,\n    sourceData.key,\n    targetData.key,\n    sourceData.attributes,\n    targetData.attributes,\n    edgeData.undirected\n  );\n}\n\nfunction forEachForKeyMulti(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData) return;\n\n  edgesData.forEach(edgeData =>\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    )\n  );\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction findForKeySimple(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    )\n  )\n    return edgeData.key;\n}\n\nfunction findForKeyMulti(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData) return;\n\n  let shouldBreak = false;\n\n  const iterator = edgesData.values();\n  let step, edgeData;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    edgeData = step.value;\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  const v = object[k];\n\n  if (v instanceof Set) {\n    const iterator = v.values();\n\n    return new Iterator(function () {\n      const step = iterator.next();\n\n      if (step.done) return step;\n\n      const edgeData = step.value;\n\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    });\n  }\n\n  return Iterator.of([\n    v.key,\n    v.attributes,\n    v.source.key,\n    v.target.key,\n    v.source.attributes,\n    v.target.attributes\n  ]);\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    if (typeof Array.from === 'function')\n      return Array.from(graph._edges.keys());\n\n    return take(graph._edges.keys(), graph._edges.size);\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n  }\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction findEdge(graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return Iterator.empty();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    let step, data;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      step = iterator.next();\n\n      if (step.done) return step;\n\n      data = step.value;\n\n      if (shouldFilter && data.undirected !== mask) continue;\n\n      break;\n    }\n\n    const value = {\n      edge: data.key,\n      attributes: data.attributes,\n      source: data.source.key,\n      target: data.target.key,\n      sourceAttributes: data.source.attributes,\n      targetAttributes: data.target.attributes,\n      undirected: data.undirected\n    };\n\n    return {value, done: false};\n  });\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = [];\n\n  const fn = multi ? collectMulti : collectSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') fn(edges, nodeData.in);\n    if (direction !== 'in') fn(edges, nodeData.out);\n\n    // Handling self loop edge case\n    if (!direction && nodeData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(nodeData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    fn(edges, nodeData.undirected);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') fn(nodeData.in, callback);\n    if (direction !== 'in')\n      fn(nodeData.out, callback, !direction ? nodeData.key : null);\n  }\n\n  if (type !== 'directed') {\n    fn(nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction findEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? findMulti : findSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(nodeData.in, callback);\n\n      if (found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(nodeData.out, callback, !direction ? nodeData.key : null);\n\n      if (found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(nodeData.undirected, callback);\n\n    if (found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : null)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const fn = multi ? collectForKeyMulti : collectForKeySimple;\n\n  const edges = [];\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(edges, sourceData.in, target);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      fn(edges, sourceData.out, target);\n\n    // Handling self loop edge case\n    if (!direction && sourceData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(sourceData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(edges, sourceData.undirected, target);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over edges for the given path using a callback.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(sourceData.in, target, callback);\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n        fn(sourceData.out, target, callback);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(sourceData.undirected, target, callback);\n  }\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction findEdgeForPath(type, multi, direction, sourceData, target, callback) {\n  const fn = multi ? findForKeyMulti : findForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(sourceData.in, target, callback);\n\n      if (found) return found;\n    }\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in') {\n        found = fn(\n          sourceData.out,\n          target,\n          callback,\n          !direction ? sourceData.key : null\n        );\n\n        if (found) return found;\n      }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(sourceData.undirected, target, callback);\n\n      if (found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return findEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return findEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return findEdgeForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {NotFoundGraphError, InvalidArgumentsGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function merging neighbors into the given set iterating over the given object.\n *\n * @param {BasicSet} neighbors - Neighbors set.\n * @param {object}   object    - Target object.\n */\nfunction merge(neighbors, object) {\n  if (typeof object === 'undefined') return;\n\n  for (const neighbor in object) neighbors.add(neighbor);\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const neighbors = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      merge(neighbors, nodeData.in);\n    }\n    if (direction !== 'in') {\n      merge(neighbors, nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    merge(neighbors, nodeData.undirected);\n  }\n\n  return take(neighbors.values(), neighbors.size);\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    callback(neighborData.key, neighborData.attributes);\n  }\n}\n\nfunction forEachInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key)) continue;\n\n    visited.add(neighborData.key);\n\n    callback(neighborData.key, neighborData.attributes);\n  }\n}\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction findInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction findInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key)) continue;\n\n    visited.add(neighborData.key);\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighborForNode(type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      forEachInObjectOnce(visited, nodeData, nodeData.in, callback);\n    }\n    if (direction !== 'in') {\n      forEachInObjectOnce(visited, nodeData, nodeData.out, callback);\n    }\n  }\n\n  if (type !== 'directed') {\n    forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n  }\n}\n\nfunction findNeighbor(type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return findInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return findInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = findInObjectOnce(visited, nodeData, nodeData.in, callback);\n\n      if (found) return found;\n    }\n    if (direction !== 'in') {\n      found = findInObjectOnce(visited, nodeData, nodeData.out, callback);\n\n      if (found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = findInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n\n    if (found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createObjectIterator(nodeData, object) {\n  const keys = Object.keys(object),\n    l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    return {\n      done: false,\n      value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n    };\n  });\n}\n\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object),\n    l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    if (i >= l) return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key)) return next();\n\n    visited.add(neighborData.key);\n\n    return {\n      done: false,\n      value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createObjectIterator(nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createObjectIterator(nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighborForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return findNeighbor(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Adjacency Iteration\n * ================================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nexport function forEachAdjacencySimple(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        hasEdges = true;\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected\n        );\n\n        if (breakable && shouldBreak) return edgeData;\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        if (targetData.key !== neighbor) targetData = edgeData.source;\n\n        hasEdges = true;\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected\n        );\n\n        if (breakable && shouldBreak) return edgeData;\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function iterating over a multi graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nexport function forEachAdjacencyMulti(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step;\n  let sourceData;\n  let neighbor;\n  let container;\n  let containerStep;\n  let adj;\n  let edgeData;\n  let targetData;\n  let shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        container = adj[neighbor].values();\n\n        while (\n          ((containerStep = container.next()), containerStep.done !== true)\n        ) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n        }\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        container = adj[neighbor].values();\n\n        while (\n          ((containerStep = container.next()), containerStep.done !== true)\n        ) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n        }\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n\n// export function createAdjacencyIteratorSimple(graph) {\n//   const iterator = graph._nodes.values();\n\n//   const type = graph.type;\n\n//   let state = 'outer',\n//     sourceData,\n//     neighbors,\n//     adj,\n//     offset;\n\n//   return new Iterator(function next() {\n//     let step;\n\n//     if (state === 'outer') {\n//       step = iterator.next();\n\n//       if (step.done === true) return step;\n\n//       sourceData = step.value;\n\n//       state = 'directed';\n//       return next();\n//     }\n\n//     if (state === 'directed') {\n//       if (type === 'undirected') {\n//         state = 'undirected';\n//         return next();\n//       }\n\n//       adj = sourceData.out;\n//       neighbors = Object.keys(sourceData.out);\n//       offset = 0;\n//       state = 'inner-directed';\n\n//       return next();\n//     }\n\n//     if (state === 'undirected') {\n//       if (type === 'directed') {\n//         state = 'outer';\n//         return next();\n//       }\n\n//       adj = sourceData.undirected;\n//       neighbors = Object.keys(sourceData.undirected);\n//       offset = 0;\n//       state = 'inner-undirected';\n//     }\n\n//     // Inner\n//     if (offset >= neighbors.length) {\n//       if (state === 'inner-undirected') state = 'outer';\n//       else state = 'undirected';\n\n//       return next();\n//     }\n\n//     const neighbor = neighbors[offset++];\n//     const edgeData = adj[neighbor];\n//     let targetData = edgeData.target;\n\n//     if (state === 'inner-undirected' && targetData.key === sourceData.key)\n//       targetData = edgeData.source;\n\n//     return {\n//       done: false,\n//       value: {\n//         source: sourceData.key,\n//         target: targetData.key,\n//         sourceAttributes: sourceData.attributes,\n//         targetAttributes: targetData.attributes,\n//         edgeKey: edgeData.key,\n//         edgeAttributes: edgeData.attributes,\n//         undirected: edgeData.undirected\n//       }\n//     };\n//   });\n// }\n\n// export function createAdjacencyIteratorMulti(graph) {\n//   const iterator = graph._nodes.values();\n\n//   const type = graph.type;\n\n//   let state = 'outer',\n//     sourceData,\n//     neighbors,\n//     container = null,\n//     adj,\n//     offset;\n\n//   return new Iterator(function next() {\n//     let step;\n\n//     if (state === 'outer') {\n//       step = iterator.next();\n\n//       if (step.done === true) return step;\n\n//       sourceData = step.value;\n\n//       state = 'directed';\n//       return next();\n//     }\n\n//     if (state === 'directed') {\n//       if (type === 'undirected') {\n//         state = 'undirected';\n//         return next();\n//       }\n\n//       adj = sourceData.out;\n//       neighbors = Object.keys(sourceData.out);\n//       offset = 0;\n//       state = 'inner-directed';\n\n//       return next();\n//     }\n\n//     if (state === 'undirected') {\n//       if (type === 'directed') {\n//         state = 'outer';\n//         return next();\n//       }\n\n//       adj = sourceData.undirected;\n//       neighbors = Object.keys(sourceData.undirected);\n//       offset = 0;\n//       state = 'inner-undirected';\n//     }\n\n//     // Inner\n//     if (!container && offset >= neighbors.length) {\n//       if (state === 'inner-undirected') state = 'outer';\n//       else state = 'undirected';\n\n//       return next();\n//     }\n\n//     if (!container) {\n//       const neighbor = neighbors[offset++];\n//       container = adj[neighbor].values();\n//       return next();\n//     }\n\n//     step = container.next();\n\n//     if (step.done) {\n//       container = null;\n//       return next();\n//     }\n\n//     const edgeData = step.value;\n//     let targetData = edgeData.target;\n\n//     if (state === 'inner-undirected' && targetData.key === sourceData.key)\n//       targetData = edgeData.source;\n\n//     return {\n//       done: false,\n//       value: {\n//         source: sourceData.key,\n//         target: targetData.key,\n//         sourceAttributes: sourceData.attributes,\n//         targetAttributes: targetData.attributes,\n//         edge: edgeData.key,\n//         edgeAttributes: edgeData.attributes,\n//         undirected: edgeData.undirected\n//       }\n//     };\n//   });\n// }\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used to validate import-export formats & to ouput\n * them from internal graph data.\n *\n * Serialized Node:\n * {key, ?attributes}\n *\n * Serialized Edge:\n * {key?, source, target, attributes?, undirected?}\n *\n * Serialized Graph:\n * {nodes[], edges?[]}\n */\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value)) return 'not-object';\n\n  if (!('key' in value)) return 'no-key';\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    return 'invalid-attributes';\n\n  return null;\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value)) return 'not-object';\n\n  if (!('source' in value)) return 'no-source';\n\n  if (!('target' in value)) return 'no-target';\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    return 'invalid-attributes';\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    return 'invalid-undirected';\n\n  return null;\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport {\n  updateStructureIndex,\n  clearEdgeFromStructureIndex,\n  clearStructureIndex,\n  upgradeStructureIndexToMulti\n} from './indices';\n\nimport attachNodeAttributesMethods from './attributes/nodes';\nimport attachEdgeAttributesMethods from './attributes/edges';\nimport attachEdgeIterationMethods from './iteration/edges';\nimport attachNeighborIterationMethods from './iteration/neighbors';\nimport {\n  forEachAdjacencySimple,\n  forEachAdjacencyMulti\n} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isGraph,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalIdStartingFromRandomByte,\n  validateHints\n} from './utils';\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    } else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  } else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    } else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source);\n  let targetData = graph._nodes.get(target);\n  let edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are coherent\n      if (\n        edgeData.source.key !== source ||\n        edgeData.target.key !== target ||\n        (undirected &&\n          (edgeData.source.key !== target || edgeData.target.key !== source))\n      ) {\n        throw new UsageGraphError(\n          `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n        );\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    const info = [alreadyExistingEdgeData.key, false, false, false];\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return info;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return info;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  let sourceWasAdded = false;\n  let targetWasAdded = false;\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n    sourceWasAdded = true;\n\n    if (source === target) {\n      targetData = sourceData;\n      targetWasAdded = true;\n    }\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n    targetWasAdded = true;\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    } else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  } else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    } else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return [edge, true, sourceWasAdded, targetWasAdded];\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instanceId = INSTANCE_ID();\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = 'geid_' + instanceId + '_' + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.out[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.undirected[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n\n      if (!edges)\n        edges =\n          typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.directedSelfLoops;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree + nodeData.directedSelfLoops;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    const loops = nodeData.directedSelfLoops;\n\n    const inDegree = nodeData.inDegree + loops;\n    const outDegree = nodeData.outDegree + loops;\n\n    return inDegree + outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    const loops = nodeData.undirectedSelfLoops;\n\n    return nodeData.undirectedDegree + loops * 2;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree + nodeData.undirectedSelfLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree +=\n        nodeData.inDegree + nodeData.outDegree + nodeData.directedSelfLoops * 2;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key;\n    const target = data.target.key;\n\n    if (node === source) return target;\n    if (node === target) return source;\n\n    throw new NotFoundGraphError(\n      `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n    );\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return [node, false];\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return [node, false];\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Removing attached edges\n    // TODO: we could do faster\n    this.forEachEdge(node, edge => {\n      this.dropEdge(edge);\n    });\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0],\n        target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    // Dropping the edge from the register\n    this._edges.delete(edgeData.key);\n\n    // Updating related degrees\n    const {source: sourceData, target: targetData, attributes} = edgeData;\n\n    const undirected = edgeData.undirected;\n\n    if (sourceData === targetData) {\n      if (undirected) {\n        sourceData.undirectedSelfLoops--;\n        this._undirectedSelfLoopCount--;\n      } else {\n        sourceData.directedSelfLoops--;\n        this._directedSelfLoopCount--;\n      }\n    } else {\n      if (undirected) {\n        sourceData.undirectedDegree--;\n        targetData.undirectedDegree--;\n      } else {\n        sourceData.outDegree--;\n        targetData.inDegree--;\n      }\n    }\n\n    // Clearing index\n    clearEdgeFromStructureIndex(this, undirected, edgeData);\n\n    if (undirected) this._undirectedSize--;\n    else this._directedSize--;\n\n    // Emitting\n    this.emit('edgeDropped', {\n      key: edge,\n      attributes,\n      source: sourceData.key,\n      target: targetData.key,\n      undirected\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    clearStructureIndex(this);\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method updating the graph's attributes.\n   *\n   * @param  {function} updater - Function used to update the attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given updater is not a function.\n   */\n  updateAttributes(updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttributes: provided updater is not a function.'\n      );\n\n    this._attributes = updater(this._attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'update',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData, sourceData, targetData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      sourceData = edgeData.source;\n      targetData = edgeData.target;\n\n      edgeData.attributes = updater(\n        edgeData.key,\n        edgeData.attributes,\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.undirected\n      );\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntry: expecting a callback.'\n      );\n\n    if (this.multi) forEachAdjacencyMulti(false, false, false, this, callback);\n    else forEachAdjacencySimple(false, false, false, this, callback);\n  }\n  forEachAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    if (this.multi) forEachAdjacencyMulti(false, false, true, this, callback);\n    else forEachAdjacencySimple(false, false, true, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's assymetric adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAssymetricAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'\n      );\n\n    if (this.multi) forEachAdjacencyMulti(false, true, false, this, callback);\n    else forEachAdjacencySimple(false, true, false, this, callback);\n  }\n  forEachAssymetricAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    if (this.multi) forEachAdjacencyMulti(false, true, true, this, callback);\n    else forEachAdjacencySimple(false, true, true, this, callback);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    if (typeof Array.from === 'function') return Array.from(this._nodes.keys());\n\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done) return step;\n\n      const data = step.value;\n\n      return {\n        value: {node: data.key, attributes: data.attributes},\n        done: false\n      };\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method exporting the target node.\n   *\n   * @param  {any}   node - Target node.\n   * @return {array}      - The serialized node.\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  exportNode(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.exportNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    return serializeNode(node, data);\n  }\n\n  /**\n   * Method exporting the target edge.\n   *\n   * @param  {any}   edge - Target edge.\n   * @return {array}      - The serialized edge.\n   *\n   * @throws {Error} - Will throw if the edge is not found.\n   */\n  exportEdge(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.exportEdge: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return serializeEdge(edge, data);\n  }\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(key, data);\n    });\n\n    return {\n      attributes: this.getAttributes(),\n      nodes,\n      edges,\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      }\n    };\n  }\n\n  /**\n   * Method used to import a serialized node.\n   *\n   * @param  {object} data   - The serialized node.\n   * @param  {boolean} merge - Whether to merge the given node.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importNode(data, merge = false) {\n    // Validating\n    const error = validateSerializedNode(data);\n\n    if (error) {\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n        );\n      if (error === 'no-key')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importNode: no key provided.'\n        );\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.'\n        );\n    }\n\n    // Adding the node\n    const {key, attributes = {}} = data;\n\n    if (merge) this.mergeNode(key, attributes);\n    else this.addNode(key, attributes);\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized edge.\n   *\n   * @param  {object}  data  - The serialized edge.\n   * @param  {boolean} merge - Whether to merge the given edge.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importEdge(data, merge = false) {\n    // Validating\n    const error = validateSerializedEdge(data);\n\n    if (error) {\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n        );\n      if (error === 'no-source')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: missing souce.'\n        );\n      if (error === 'no-target')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: missing target.'\n        );\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.'\n        );\n      if (error === 'invalid-undirected')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.'\n        );\n    }\n\n    // Adding the edge\n    const {source, target, attributes = {}, undirected = false} = data;\n\n    let method;\n\n    if ('key' in data) {\n      method = merge\n        ? undirected\n          ? this.mergeUndirectedEdgeWithKey\n          : this.mergeDirectedEdgeWithKey\n        : undirected\n        ? this.addUndirectedEdgeWithKey\n        : this.addDirectedEdgeWithKey;\n\n      method.call(this, data.key, source, target, attributes);\n    } else {\n      method = merge\n        ? undirected\n          ? this.mergeUndirectedEdge\n          : this.mergeDirectedEdge\n        : undirected\n        ? this.addUndirectedEdge\n        : this.addDirectedEdge;\n\n      method.call(this, source, target, attributes);\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance\n    if (isGraph(data)) {\n      this.import(data.export(), merge);\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) this.importNode(list[i], merge);\n    }\n\n    if (data.edges) {\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) this.importEdge(list[i], merge);\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n    graph.replaceAttributes(assign({}, this.getAttributes()));\n    return graph;\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @return {Graph} - The copy.\n   */\n  copy() {\n    const graph = this.emptyCopy();\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      addEdge(\n        graph,\n        'copy',\n        false,\n        edgeData.undirected,\n        edgeData.key,\n        edgeData.source.key,\n        edgeData.target.key,\n        assign({}, edgeData.attributes)\n      );\n    }\n\n    return graph;\n  }\n\n  /**\n   * Method upgrading the graph to a mixed one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMixed() {\n    if (this.type === 'mixed') return this;\n\n    // Upgrading node data:\n    // NOTE: maybe this could lead to some de-optimization by usual\n    // JavaScript engines but I cannot be sure of it. Another solution\n    // would be to reinstantiate the classes but this surely has a performance\n    // and memory impact.\n    this._nodes.forEach(data => data.upgradeToMixed());\n\n    // Mutating the options & the instance\n    this._options.type = 'mixed';\n    readOnlyProperty(this, 'type', this._options.type);\n    privateProperty(this, 'NodeDataClass', MixedNodeData);\n\n    return this;\n  }\n\n  /**\n   * Method upgrading the graph to a multi one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMulti() {\n    if (this.multi) return this;\n\n    // Mutating the options & the instance\n    this._options.multi = true;\n    readOnlyProperty(this, 'multi', true);\n\n    // Upgrading indices\n    upgradeStructureIndexToMulti(this);\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function' &&\n        typeof k !== 'symbol'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Attributes-related.\n */\nattachNodeAttributesMethods(Graph);\nattachEdgeAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n"],"names":["assign","target","arguments","i","l","length","k","getMatchingEdge","graph","source","type","sourceData","_nodes","get","edge","out","undirected","isGraph","value","_typeof","addUndirectedEdgeWithKey","dropNode","isPlainObject","constructor","Object","isEmpty","o","privateProperty","name","defineProperty","enumerable","configurable","writable","readOnlyProperty","descriptor","validateHints","hints","attributes","Array","isArray","ReflectOwnKeys","R","Reflect","ReflectApply","apply","receiver","args","Function","prototype","call","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","EventEmitter","init","this","emitter","Promise","resolve","reject","errorListener","err","removeListener","resolver","slice","eventTargetAgnosticAddListener","once","handler","flags","on","addErrorHandlerIfEventEmitter","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","prepend","m","events","existing","warning","create","newListener","emit","unshift","push","warned","w","Error","String","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","unwrapListeners","arrayClone","listenerCount","n","copy","addEventListener","wrapListener","arg","removeEventListener","Iterator","next","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","Symbol","iterator","of","done","empty","fromSequence","sequence","is","ArrayBuffer","require$$0","support","require$$1","ARRAY_BUFFER_SUPPORT","SYMBOL_SUPPORT","iter","isView","iterOrNull","take","iterable","step","Infinity","array","GraphError","InvalidArgumentsGraphError","captureStackTrace","NotFoundGraphError","UsageGraphError","MixedNodeData","clear","DirectedNodeData","UndirectedNodeData","EdgeData","updateStructureIndex","edgeData","targetData","adj","container","outKey","inKey","multi","Set","add","clearEdgeFromStructureIndex","sourceIndex","size","inDegree","outDegree","undirectedDegree","directedSelfLoops","undirectedSelfLoops","upgradeToMixed","findRelevantNodeData","method","mode","nodeOrEdge","nameOrEdge","add1","add2","nodeData","arg1","arg2","_edges","NODE_ATTRIBUTES_METHODS","element","attacher","Class","data","hasOwnProperty","updater","EDGE_ATTRIBUTES_METHODS","chain","current","iterables","iterate","EDGES_ITERATION","direction","collectSimple","edges","object","collectMulti","forEach","forEachSimple","callback","avoid","forEachMulti","findSimple","findMulti","values","createIterator","inner","sourceAttributes","targetAttributes","collectForKeySimple","collectForKeyMulti","edgesData","forEachForKeySimple","forEachForKeyMulti","findForKeySimple","findForKeyMulti","createIteratorForKey","v","createEdgeArray","from","undirectedSize","directedSize","mask","forEachEdge","shouldFilter","findEdge","createEdgeIterator","createEdgeArrayForNode","fn","splice","lastIndexOf","forEachEdgeForNode","findEdgeForNode","found","createEdgeIteratorForNode","createEdgeArrayForPath","forEachEdgeForPath","findEdgeForPath","createEdgeIteratorForPath","NEIGHBORS_ITERATION","merge","neighbors","neighbor","forEachInObject","neighborData","forEachInObjectOnce","visited","has","findInObject","findInObjectOnce","createObjectIterator","createDedupedObjectIterator","attachNeighborArrayCreator","description","node","createNeighborArrayForNode","attachForEachNeighbor","forEachName","toUpperCase","forEachNeighborForNode","mapName","result","a","filterName","reduceName","initialValue","accumulator","attachFindNeighbor","capitalizedSingular","findName","findNeighbor","someName","everyName","attachNeighborIteratorCreator","iteratorName","createNeighborIterator","forEachAdjacencySimple","breakable","assymetric","disconnectedNodes","shouldBreak","hasEdges","forEachAdjacencyMulti","containerStep","serializeNode","serialized","serializeEdge","validateSerializedNode","validateSerializedEdge","INSTANCE_ID","Math","floor","random","TYPES","EMITTER_PROPS","DEFAULTS","allowSelfLoops","unsafeAddNode","NodeDataClass","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","_undirectedSelfLoopCount","_directedSelfLoopCount","_undirectedSize","_directedSize","mergeEdge","asUpdater","alreadyExistingEdgeData","info","oldAttributes","sourceWasAdded","targetWasAdded","Graph","options","instanceId","edgeId","Map","availableEdgeKey","_this","prop","_options","_resetInstanceCounters","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undirectedEdge","areDirectedNeighbors","areOutNeighbors","areInNeighbors","areUndirectedNeighbors","areNeighbors","areInboundNeighbors","areOutboundNeighbors","directedDegree","loops","degree","inDegreeWithoutSelfLoops","outDegreeWithoutSelfLoops","directedDegreeWithoutSelfLoops","undirectedDegreeWithoutSelfLoops","degreeWithoutSelfLoops","extremities","opposite","hasExtremity","isUndirected","isDirected","isSelfLoop","addNode","mergeNode","updateNode","_this2","dropEdge","clearEdges","clearStructureIndex","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","updateAttributes","updateEachNodeAttributes","updateEachEdgeAttributes","forEachAdjacencyEntry","forEachAdjacencyEntryWithOrphans","forEachAssymetricAdjacencyEntry","forEachAssymetricAdjacencyEntryWithOrphans","nodes","forEachNode","findNode","mapNodes","order","someNode","everyNode","filterNodes","reduceNodes","nodeEntries","exportNode","exportEdge","importNode","importEdge","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addDirectedEdgeWithKey","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","upgradeToMulti","toJSON","toString","inspect","multiIndex","tmp","label","desc","startsWith","_this3","dummy","verb","generateKey","attachNodeAttributesMethods","attachEdgeAttributesMethods","attachEdgeArrayCreator","e","ea","s","t","sa","ta","u","attachForEachEdge","findEdgeName","attachFindEdge","originalName","attachEdgeIteratorCreator","attachEdgeIterationMethods","attachNeighborIterationMethods","DirectedGraph","finalOptions","_Graph","UndirectedGraph","_Graph2","MultiGraph","_Graph3","MultiDirectedGraph","_Graph4","MultiUndirectedGraph","_Graph5","attachStaticFromMethod","instance"],"mappings":"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"}